#  Linux C编程一站式学习笔记

[Linux C编程一站式学习 (akaedu.github.io)](http://akaedu.github.io/book/index.html)

##  一、程序基本概念

###  1、程序和编程语言

* 程序有一系列指令组成，通常包括以下几种：

  * 输入
  * 输出
  * 基本运算
  * 测试分支
  * 循环

* **编写程序可以说就是这样一个过程：把复杂的任务分解成子任务，把子任务再分解成更简单的任务，层层分解，直到最后简单得可以用以上指令来完成。**

* 平台的解释：

  * 计算机体系结构
  * 操作系统
  * 开发平台（编译器、链接器等）

* 编译（compile）过程

  ![编译执行的过程](./images_学习笔记\intro.compile.png)

  * 用文本编辑器写一个C程序，然后保存成一个文件，例如`program.c`（通常C程序的文件名后缀是`.c`），这称为源代码（Source Code）或源文件，
  * 运行编译器编译源文件，编译的过程并不执行程序，而是把源代码全部翻译成机器指令，再加上一些描述信息，生成一个新的文件，例如`a.out`，这称为可执行文件
  * 可执行文件可以被操作系统加载运行，计算机执行该文件中由编译器生成的指令

* 解释（Interpret）过程

  ![解释执行的过程](./images_学习笔记\intro.interpret.png)

* 编程语言演化

  * 机器语言称为第一代语言（1GL，1st Generation Programming Language）
  * 汇编语言称为第二代语言（2GL，2nd Generation Programming Language）
  * C、C++、Java、Python等可以称为第三代语言（3GL，3rd Generation Programming Language）
  * 4GL（4th Generation Programming Language），例如SQL语言（SQL，Structured Query Language，结构化查询语言）
    * 4GL以后的编程语言更多是描述要做什么（Declarative）而不描述具体一步一步怎么做（Imperative）
  * 5GL（5th Generation Programming Language）

###  问题

1. 解释执行的语言相比编译执行的语言有什么优缺点?

> 解释执行的语言
>
> 优点：
>
> 1、解释执行不依赖于平台，因为编译器会根据不同的平台进行解析
>
> 2、开发速度快，出现严重BUG的几率小
>
> 缺点：
>
> 1、解析需要时间，不生成目标程序而是一句一句执行的方式会造成计算机资源的浪费，即执行效率低
>
> 2、解释语言需要把源代码交给用户

> 编译执行：
>
> 优点
>
> 1、相较于解释执行，编译执行的效率高，占用资源小，适合复杂程序
>
> 缺点：
>
> 兼容性差



##  二、自然语言和形式语言

* 1、自然语言：不是人为设计（虽然有人试图强加一些规则）而是自然进化的语言

  ​	  形式语言：为了特定应用而人为设计的语言

* 2、形式语言有严格的`语法`（Syntax）规则，语法规则是由`符号`（Token）和结构（Structure）的规则所组成的

  * Token的概念相当于自然语言中的单词和标点、数学式中的数和运算符、化学分子式中的元素名和数字
  * 结构是指Token的排列方式
  * 关于Token的规则称为`词法（Lexical）规则`，而关于结构的规则称为`语法（Grammar）规则`[^1]

* 3、自然语言和形式语言的区别：

  * 歧义性
  * 冗余性
  * 与字面意思的一致性（隐喻）

[^1]:很不幸，Syntax和Grammar通常都翻译成“语法”，这让初学者非常混乱，Syntax的含义其实包含了Lexical和Grammar的规则，还包含一部分语义的规则，例如在C程序中变量应先声明后使用。即使在英文的文献中Syntax和Grammar也常混用，在有些文献中Syntax的含义不包括Lexical规则，只要注意上下文就不会误解。另外，本书在翻译容易引起混淆的时候通常直接用英文名称，例如Token没有十分好的翻译，直接用英文名称。

##  三、程序的调试

* BUG类型
  * 编译时错误：导致编译器无法继续编译的错误。一般是语法错误。
  * 运行时错误：编译器检查不出，仍然可以生成可执行文件，但在运行时会出错而导致程序崩溃的错误
  * 逻辑错误和语义错误：可正常运行，但所实现的功能与设计不符。一般是程序的意思（即语义）是错的

##  四、第一个程序

程序实例

~~~C
#include <stdio.h>

/* main: generate some simple output */

int main(void)
{
	printf("Hello, world.\n");
	return 0;
}
~~~

将这个程序保存成`main.c`，然后编译执行：

~~~C
$ gcc main.c
$ ./a.out
Hello, world.
~~~

`gcc`是Linux平台的C编译器，编译后在当前目录下生成可执行文件`a.out`，直接在命令行输入这个可执行文件的路径就可以执行它。如果不想把文件名叫`a.out`，可以用`gcc`的`-o`参数自己指定文件名：

~~~C
$ gcc main.c -o main
$ ./main
Hello, world.
~~~

* 警告信息不是致命错误，编译仍然可以继续，如果整个编译过程只有警告信息而没有错误信息，仍然可以生成可执行文件
* 警告信息也是不容忽视的。出警告信息说明你的程序写得不够规范，可能有Bug，虽然能编译生成可执行文件，但程序的运行结果往往是不正确的
* **一个好的习惯是打开`gcc`的`-Wall`选项，也就是让`gcc`提示所有的警告信息，不管是严重的还是不严重的，然后把这些问题从代码中全部消灭**

###  习题

1、尽管编译器的错误提示不够友好，但仍然是学习过程中一个很有用的工具。你可以像上面那样，从一个正确的程序开始每次改动一小点，然后编译看是什么结果，如果出错了，就尽量记住编译器给出的错误提示并把改动还原。因为错误是你改出来的，你已经知道错误原因是什么了，所以能很容易地把错误原因和错误提示信息对应起来记住，这样下次你在毫无防备的情况下撞到这个错误提示时就会很容易想到错误原因是什么了。这样反复练习，有了一定的经验积累之后面对编译器的错误提示就会从容得多了。

##  五、以HelloWorld为例介绍部分编程规范

* 注释方式为`/**/`，可跨行，可穿插代码中，但**不可嵌套**

* `//`此注释方式是从C++中借鉴的语法，不可跨行，不可穿插

* 由双引号（Double Quote）引起来的一串字符称为字符串字面值（String Literal），或者简称字符串。

  > 程序的运行结果并没有双引号，`printf`打印出来的只是里面的一串字符`Hello, world.`，因此双引号是字符串字面值的界定符，夹在双引号中间的一串字符才是它的内容

  * 在程序中其他地方的空格、Tab和换行多一个少一个往往无关紧要，但有些场合有所要求或区别，例如，双引号中空格也算一个字符，`int`和`main`之间至少隔一个空格

* 转义字符

  ![](./images_学习笔记/转义字符.png)

  * 转义序列有两个作用:
    * 把普通字符转义成特殊字符，例如把字母n转义成换行符
    * 把特殊字符转义成普通字符，例如\和"是特殊字符，转义后取它的字面值



##  六、常量（易忽略的知识点）

* 单引号只能括一个字符或一个转义序列，而双引号可以括一串字符串
* 字符串字面值中需使用转义序列才能打印出`''`，`""`，`?`，`\`，而字符常量既可以使用转义序列`\'`和`\?`，也可以直接用字符`""`和`?`，**而要表示'和\则必须使用转义序列**
* `printf`中的第一个字符串称为格式化字符串（Format String），它规定了后面几个常量以何种格式插入到这个字符串中
  * 在格式化字符串中%号（Percent Sign）后面加上字母c、d、f分别表示字符型、整型和浮点型的转换说明（Conversion Specification）
  * 转换说明只在格式化字符串中占个位置，并不出现在最终的打印结果中，这种用法通常叫做占位符（Placeholder）
* **转义序列是编译时处理的，而转换说明是在运行时调用`printf`函数处理的**

###  习题

1、总结前面介绍的转义序列的规律，想想在`printf`的格式化字符串中怎么表示一个%字符？写个小程序试验一下。

##  七、变量

* 定义：计算机存储器中的一块命名的空间，大小由类型决定
* 作用：存储一个值
* 特点：存储的值随时可变；需声明后使用
* 声明：可单独声明，同一类型的变量可同时声明

> **声明与定义**
>
> * C中声明（Declaration）有变量声明、函数声明和类型声明三种。
>
> * 一个变量或函数的声明要求编译器为它分配存储空间，那么也可以称为定义（Definition）
> * 声明一个类型是不分配存储空间的
> * 声明和语句类似，也是以;号结尾的，但是在语法上声明和语句是有区别的，语句只能出现在{}括号中，而声明既可以出现在{}中也可以出现在所有{}之外

* 变量名取名规则
  * 以字母或下划线_（Underscore）开头，后面可以跟若干个字母、数字、下划线，但不能有其它字符
  * 关键字（Keyword）或保留字（Reserved Word）不能用做标识符
  * **一般来说应避免使用以下划线开头的标识符**，以下划线开头的标识符只要不和C语言关键字冲突的都是合法的，但是往往被编译器用作一些功能扩展，C标准库也定义了很多以下划线开头的标识符
* 标识符：函数名、宏定义、结构体成员名、变量名等



##  八、赋值

* 定义：将值放入变量所代表的存储空间的过程

  ~~~C
  type varname = 值;
  ~~~

  此处`=`用作赋值，而不是等于

* `i=i+1` 在C语言中表示把变量`i`的存储空间中的值取出来，再加上1，得到的结果再存回`i`的存储空间中

* 在C语言中，`a=7`合法，`7=a`不合法

* 变量的定义和赋值也可以一步完成，这称为变量的初始化（Initialization）

* **初始化是一种特殊的声明，而不是一种赋值语句**

* 变量名用在等号左边表示赋值，而用在`printf`中表示把它的存储空间中的值取出来替换在那里

##  九、表达式

* 定义：由运算符和操作数所组成的算式

  * 操作数：参与运算的常量和变量

* 运算符优先级

  * 优先级高的先运算

  * 同一优先级的运算从左到右进行

  * | 类别       | 运算符                                 | 结合性   |
    | :--------- | :------------------------------------- | :------- |
    | 后缀       | () [] -> . ++ - -                      | 从左到右 |
    | 一元       | + - ! ~ ++ - -[^前缀] (type)* & sizeof | 从右到左 |
    | 乘除       | * / %                                  | 从左到右 |
    | 加减       | + -                                    | 从左到右 |
    | 移位       | << >>                                  | 从左到右 |
    | 关系       | < <= > >=                              | 从左到右 |
    | 相等       | == !=                                  | 从左到右 |
    | 位与 AND   | &                                      | 从左到右 |
    | 位异或 XOR | ^                                      | 从左到右 |
    | 位或 OR    | \|                                     | 从左到右 |
    | 逻辑与 AND | &&                                     | 从左到右 |
    | 逻辑或 OR  | \|\|                                   | 从左到右 |
    | 条件       | ?:                                     | 从右到左 |
    | 赋值       | = += -= *= /= %=>>= <<= &= ^= \|=      | 从右到左 |
    | 逗号       | ,                                      | 从左到右 |

    [^前缀]:此处++和--是前缀运算符，即`++a`、`--b`

  * ```
    括号成员是老大;      // 括号运算符 []() 成员运算符.  ->
    
    全体单目排老二;      // 所有的单目运算符比如++、 --、 +(正)、 -(负) 、指针运算*、&、sizeof
    
    乘除余三,加减四;    // 这个"余"是指取余运算即%
    
    移位五，关系六;     // 移位运算符：<< >> ，关系：> < >= <= 等
    
    等与不等排行七;     // 即 == 和 !=
    
    位与异或和位或;     // 这几个都是位运算: 位与(&)异或(^)位或(|)    
    
    "三分天下"八九十;  
    
    逻辑与，逻辑或;    // 逻辑运算符: || 和 &&
    
    十一十二紧挨着;    // 注意顺序: 优先级(||)  底于 优先级(&&) 
    
    条件只比赋值高,    // 三目运算符优先级排到 13 位只比赋值运算符和 "," 高
    
    逗号运算最低级!    //逗号运算符优先级最低 
    ```

  * **初等运算符>单目运算符>算术运算符>关系运算符>逻辑运算符>条件运算符>赋值运算符**

    

* 我们定义：在任意表达式后面加个;号也是一种语句，称为表达式语句

  ~~~C
  hour * 60 + minute;//仅运算，不保存计算结果
  
  int total_minute;
  total_minute = hour * 60 + minute;//运算且保存结果到total_minute中
  ~~~

* **任何表达式都有值和类型两个基本属性**

* > 如果一个表达式中出现多个等号，不是从左到右计算而是从右到左计算，例如：
  >
  > ```
  > int total_minute, total;
  > total = total_minute = hour * 60 + minute;
  > ```
  >
  > 计算顺序是先算`hour * 60 + minute`得到一个结果，然后算右边的等号，就是把`hour * 60 + minute`的结果赋给变量`total_minute`，这个结果同时也是整个表达式`total_minute = hour * 60 + minute`的值，再算左边的等号，即把这个值再赋给变量`total`。同样优先级的运算符是从左到右计算还是从右到左计算称为运算符的结合性（Associativity）。+ - * /是左结合的，等号是右结合的。

* > ```
  > printf("%d:%d is %d minutes after 00:00\n", hour, minute, hour * 60 + minute);
  > ```
  >
  > 编译器在翻译这条语句时，首先根据上述语法规则把这个语句解析成下图所示的语法树，然后再根据语法树生成相应的指令。语法树的末端的是一个个Token，每一步展开利用一条语法规则。
  >
  > **图 2.2. 语法树**
  >
  > ![语法树](./images_学习笔记\expr.parse.png)

* 左值和右值

  * 左值：表达式所表示的存储位置
  * 右值：表达式的值
  * **有的表达式既可以做左值也可以做右值，而有的表达式只能做右值**

* > 向下取整的运算称为Floor，用数学符号⌊⌋表示；向上取整的运算称为Ceiling，用数学符号⌈⌉表示。例如：
  >
  > ⌊59/60⌋=0
  > ⌈59/60⌉=1
  > ⌊-59/60⌋=-1
  > ⌈-59/60⌉=0
  >
  > **在C语言中整数除法取的既不是Floor也不是Ceiling，无论操作数是正是负总是把小数部分截掉，在数轴上向零的方向取整（Truncate toward Zero），或者说当操作数为正的时候相当于Floor，当操作符为负的时候相当于Ceiling。**



###  语法规则

* 表达式 → 标识符
* 表达式 → 常量
* 表达式 → 字符串字面值
* 表达式 → (表达式)
* 表达式 → 表达式 + 表达式
* 表达式 → 表达式 - 表达式
* 表达式 → 表达式 * 表达式
* 表达式 → 表达式 / 表达式
* 表达式 → 表达式 = 表达式
* 语句 → 表达式;
* 语句 → printf(表达式, 表达式, 表达式, ...);
* 变量声明 → 类型 标识符 = Initializer, 标识符 = Initializer, ...;（= Initializer的部分可以不写）

###  习题

1、假设变量`x`和`n`是两个正整数，我们知道`x/n`这个表达式的结果要取Floor，例如`x`是17，`n`是4，则结果是4。如果希望结果取Ceiling应该怎么写表达式呢？例如`x`是17，`n`是4，则结果是5；`x`是16，`n`是4，则结果是4。

~~~C
int quotient;
int x = 17,n = 4
    
方案一：//未验证，但感觉有点不对劲
quotient = ~(~x/n);

方案二：//未验证
quotient = (x+n-1)/n;

方案三：//未验证
quotient = x%m>0 ? x/n+1:x/n;
~~~



##  十、字符类型与字符编码

* 字符常量或字符型变量也可以当作整数参与运算，例如：

  ```c
  printf("%c\n", 'a'+1);
  ```

  执行结果是`b`。

* 符号在计算机内部也用数字表示，每个字符在计算机内部用一个整数表示，称为字符编码（Character Encoding），目前最常用的是ASCII码（American Standard Code for Information Interchange，美国信息交换标准码）

  * 常用字符

    | 字符 |   进制   |  数值  |
    | :--: | :------: | :----: |
    | 0—9  | 十六进制 | 30—39  |
    | A—Z  |  十进制  | 65—90  |
    | a—z  |  十进制  | 97—122 |

  * 字符也可以用ASCII码转义序列表示，这种转义序列由\加上1—3个八进制数字组成，或者由`\x`或大写`\X`加上1—2个十六进制数字组成，

##  十一、数学函数

* 小知识点
  * `1.0`是参数（Argument）
  * `log`是函数（Function）
  * `log(1.0)`是函数调用（Function Call）
  * 函数调用也是一种表达式，这个表达式由函数调用运算符（()括号）和两个操作数组成，操作数`log`是一个函数名（Function Designator），它的类型是一种函数类型（Function Type），操作数`1.0`是`double`型的。
  * `log(1.0)`这个表达式的值就是对数运算的结果，也是`double`型的，在C语言中函数调用表达式的值称为函数的返回值（Return Value）
* 语法规则：
  * 表达式 → 函数名
  * 表达式 → 表达式(参数列表)
  * 参数列表 → 表达式, 表达式, ...
* **C语言的函数可以有Side Effect，这一点是它和数学函数在概念上的根本区别**
  * 改变计算机存储单元里的数据或者做输入输出操作都算Side Effect
* 程序第一行的#号（Pound Sign，Number Sign或Hash Sign）和`include`表示包含一个头文件（Header File），后面尖括号（Angel Bracket）中就是文件名（这些头文件通常位于`/usr/include`目录下）。头文件中声明了我们程序中使用的库函数。
* 使用`math.h`中声明的库函数还有一点特殊之处，`gcc`命令行必须加`-lm`选项，因为数学函数位于`libm.so`库文件中（这些库文件通常位于`/lib`目录下），`-lm`选项告诉编译器，我们程序中用到的数学函数要到这个库文件里找

>  C标准库和glibc
>
> C标准主要由两部分组成，一部分描述C的语法，另一部分描述C标准库。C标准库定义了一组标准头文件，每个头文件中包含一些相关的函数、变量、类型声明和宏定义。要在一个平台上支持C语言，不仅要实现C编译器，还要实现C标准库，这样的实现才算符合C标准。不符合C标准的实现也是存在的，例如很多单片机的C语言开发工具中只有C编译器而没有完整的C标准库。
>
> 在Linux平台上最广泛使用的C函数库是`glibc`，其中包括C标准库的实现，也包括本书第三部分介绍的所有系统函数。几乎所有C程序都要调用`glibc`的库函数，所以`glibc`是Linux平台C程序运行的基础。`glibc`提供一组头文件和一组库文件，最基本、最常用的C标准库函数和系统函数在`libc.so`库文件中，几乎所有C程序的运行都依赖于`libc.so`，有些做数学计算的C程序依赖于`libm.so`，以后我们还会看到多线程的C程序依赖于`libpthread.so`。以后我说`libc`时专指`libc.so`这个库文件，而说`glibc`时指的是`glibc`提供的所有库文件。
>
> `glibc`并不是Linux平台唯一的基础C函数库，也有人在开发别的C函数库，比如适用于嵌入式系统的`uClibc`。

##  十二、自定义函数

* 语法规则：

  * 函数定义 → 返回值类型 函数名(参数列表) 函数体
  * 函数体 → { 语句列表 }
  * 语句列表 → 语句列表项 语句列表项 ...
  * 语句列表项 → 语句
  * 语句列表项 → 变量声明、类型声明或非定义的函数声明
  * 非定义的函数声明 → 返回值类型 函数名(参数列表);

* 函数调用的规则和优点

  * 同一个函数可以被多次调用。
  * 可以用一个函数调用另一个函数，后者再去调第三个函数。
  * 通过自定义函数可以给一组复杂的操作起一个简单的名字，例如`threeline`。对于`main`函数来说，只需要通过`threeline`这个简单的名字来调用就行了，不必知道打印三个空行具体怎么做，所有的复杂操作都被隐藏在`threeline`这个名字后面。
  * 使用自定义函数可以使代码更简洁

* 函数原型（Prototype）：比如`void threeline(void)`这一行，声明了一个函数的名字、参数类型和个数、返回值类型，这称为函数原型。在代码中可以单独写一个函数原型，后面加`;`号结束，而不写函数体，例如：

  ```c
  void threeline(void);//正真的函数原型
  void threeline();//不是函数原型
  ```

  这种写法只能叫函数声明而不能叫函数定义，只有带函数体的声明才叫定义

* 函数原型的作用：**为编译器提供了有用的信息**，编译器在翻译代码的过程中，只有见到函数原型（不管带不带函数体）之后才知道这个函数的名字、参数类型和返回值，这样碰到函数调用时才知道怎么生成相应的指令

* 函数调用原则：

  * 先声明后使用
  * 方式：
    * 按调用顺序编写函数
    * 通过函数原型进行声明，后续可以任意顺序进行函数编写
    * 如果不通过函数原型进行声明，先调用，后续编写函数，能编译通过，结果也正确，此处编译器认为此处**隐式声明**了`int threeline(void);`，**隐式声明的函数返回值类型都是`int`，由于我们调用这个函数时没有传任何参数，所以编译器认为这个隐式声明的参数类型是`void`**，这样函数的参数和返回值类型都确定下来了，编译器根据这些信息为函数调用生成相应的指令。然后编译器接着往下看，看到`threeline`函数的原型是`void threeline(void)`，和先前的隐式声明的返回值类型不符，所以报警告。好在我们也没用到这个函数的返回值，所以执行结果仍然正确
  
* 函数只能定义在函数外，不能定义在函数内

* 函数不允许重名，C语言中函数没有重载

* 函数只要一经定义，就可以在任意函数中调用

  注意：如果函数定义在它调用之后，那么必须在调用之前，先声明这个函数

* 声明的语法：返回值类型 函数名(参数列表);

  * tips:声明函数其实只要复制函数头，打个分号就可以了
  * 再注意： 1、函数定义的时候函数头是什么样子，那么声明的时候也必须是这个样子的
  * 2、如果有参数的函数，声明的时候可以省略形参名
  * 3、在Mac下，如果返回值类型是int的话，可以直接调用不声明(不推荐)
  * 4、函数的声明位置可以放在函数内，也可以放在函数外，但是一定要在调用函数之前
  * 5、函数的声明可以写N多个

[(3条消息) c语言声明函数格式 - CSDN](https://www.csdn.net/tags/MtjaQg0sOTgwMDgtYmxvZwO0O0OO0O0O.html)

###  问题

*  问：敏锐的读者可能会发现一个矛盾：如果函数`newline`没有返回值，那么表达式`newline()`不就没有值了吗？然而上一章讲过任何表达式都有值和类型两个基本属性

* 答：其实这正是设计`void`这么一个关键字的原因：首先从语法上规定没有返回值的函数调用表达式有一个`void`类型的值，这样任何表达式都有值，不必考虑特殊情况，编译器的语法解析比较容易实现；然后从语义上规定`void`类型的表达式不能参与运算，因此`newline() + 1`这样的表达式不能通过语义检查，从而兼顾了语法上的一致和语义上的不矛盾。

##  十三、形参和实参

* 形参（Parameter）：即形式参数，又称虚拟变量，是在定义函数名和[函数体](https://baike.baidu.com/item/函数体)的时候使用的参数,目的是用来接收调用该函数时传入的参数.

* 实参（Argument）：实际参数，是在调用时传递给函数的参数。实参可以是常量、变量、表达式、函数等，无论实参是何种类型的量，但必须具有确定的值。

* **实参的个数和数据类型必须和形参一一对应**

* **形参相当于函数中定义的变量，调用函数传递参数的过程相当于定义形参变量并且用实参的值来初始化**

* > ### Man Page
  >
  > Man Page是Linux开发最常用的参考手册，由很多页面组成，每个页面描述一个主题，这些页面被组织成若干个Section。FHS（Filesystem Hierarchy Standard）标准规定了Man Page各Section的含义如下：
  >
  > 
  >
  > **表 3.1. Man Page的Section**
  >
  > | Section | 描述                                                         |
  > | ------- | ------------------------------------------------------------ |
  > | 1       | 用户命令，例如`ls(1)`                                        |
  > | 2       | 系统调用，例如`_exit(2)`                                     |
  > | 3       | 库函数，例如`printf(3)`                                      |
  > | 4       | 特殊文件，例如`null(4)`描述了设备文件`/dev/null`、`/dev/zero`的作用 |
  > | 5       | 系统配置文件的格式，例如`passwd(5)`描述了系统配置文件`/etc/passwd`的格式 |
  > | 6       | 游戏                                                         |
  > | 7       | 其它杂项，例如`bash-builtins(7)`描述了`bash`的各种内建命令   |
  > | 8       | 系统管理命令，例如`ifconfig(8)`                              |
  >
  > 
  >
  > 注意区分用户命令和系统管理命令，用户命令通常位于`/bin`和`/usr/bin`目录，系统管理命令通常位于`/sbin`和`/usr/sbin`目录，一般用户可以执行用户命令，而执行系统管理命令经常需要`root`权限。系统调用和库函数的区别将在[第 2 节 “`main`函数和启动例程”](http://akaedu.github.io/book/ch19s02.html#asmc.main)说明。
  >
  > Man Page中有些页面有重名，比如敲`man printf`命令看到的并不是C函数`printf`，而是位于第1个Section的系统命令`printf`，要查看位于第3个Section的`printf`函数应该敲`man 3 printf`，也可以敲`man -k printf`命令搜索哪些页面的主题包含`printf`关键字。本书会经常出现类似`printf(3)`这样的写法，括号中的3表示Man Page的第3个Section，或者表示“我这里想说的是`printf`库函数而不是`printf`命令”。

###  问题

* 问：为什么参数不能和变量一样，相同类型变量一起定义，而是一个一个定义？

  即不遵循最少例外原则（Rule of Least Surprise）

* 答：

* 问：定义一个函数`increment`，它的作用是把传进来的参数加1。例如：

  ```
  void increment(int x)
  {
  	x = x + 1;
  }
  
  int main(void)
  {
  	int i = 1, j = 2;
  	increment(i); /* i now becomes 2 */
  	increment(j); /* j now becomes 3 */
  	return 0;
  }
  ```

  我们在`main`函数中调用`increment`增加变量`i`和`j`的值，这样能奏效吗？为什么？

* 答：

* 问：如果在一个程序中调用了`printf`函数却不包含头文件，例如`int main(void) { printf("\n"); }`，编译时会报警告：`warning: incompatible implicit declaration of built-in function ‘printf’`。请分析错误原因。

* 答：

##  十四、全局变量、局部变量和作用域

* 局部变量（Local Variable）：函数中定义的变量

  * 一个函数中定义的变量不能被另一个函数使用
  * 每次调用函数时局部变量都表示不同的存储空间。局部变量在每次函数调用时分配存储空间，在每次函数返回时释放存储空间。

* 全局变量（Global Variable）：定义在所有的函数体之外的变量

  * 在任何函数中都可以访问（使用）
  * 在程序开始运行时分配存储空间，在程序结束时释放存储空间

* 在程序运行过程中全局变量被读写的顺序从源代码中是看不出来的，源代码的书写顺序并不能反映函数的调用顺序。在某个不起眼的地方**对全局变量的读写顺序不正确一般会形成BUG。全局变量用起来很方便，但一定要慎用，能用函数传参代替的就不要用全局变量**

* 作用域：限定变量名的可用性的代码范围

* 局部变量和全局变量重名——根据作用域的范围判断，局部变量的作用域会覆盖全局变量的作用域

* **局部变量可以用类型相符的任意表达式来初始化，而全局变量只能用常量表达式（Constant Expression）初始化**

  ~~~C
  double pi = 3.14 + 0.0016;//合法
  double pi = acos(-1.0);//不合法
  int minute = 360;//合法
  int hour = minute / 60;//不合法
  ~~~

  

* 如果全局变量在定义时不初始化则初始值是0，如果局部变量在定义时不初始化则初始值是不确定的。所以，**局部变量在使用之前一定要先赋值**

* 非定义的函数声明也可以写在局部作用域中

* ### 问题

  ```
  #include <stdio.h>
  
  void foo(void)
  {
  	int i;
  	printf("%d\n", i);
  	i = 777;
  }
  
  int main(void)
  {
  	foo();
  	foo();
  	return 0;
  }
  ```

  结果：

  ```
  134518128
  777
  int main(void)
  {
  	foo();
  	printf("hello\n");
  	foo();
  	return 0;
  }
  ```

  结果是

  ```
  134518200
  hello
  0
  ```

  - 问：每次调用函数时局部变量都表示不同的存储空间，且局部变量不初始化则初值不确定，即每次调用这个函数时局部变量的初值可能不一样，运行环境不同，函数的调用次序不同，都会影响到局部变量的初值。问为什么这个不确定的值刚好是777，或者刚好是0？是恰好随机为777或0还是其他原因？
  - 答：



##  十五、if语句

* 控制表达式：`x != 0`表示“x不等于0”的条件

* 分支（Branch）：`if`和控制表达式改变了程序的控制流程（Control Flow），不再是从前到后顺序执行，而是根据不同的条件执行不同的语句，这种控制流程称为分支

* 小知识点

  * ==表示数学中的相等关系，相当于数学中的=号，在C语言中=号是赋值运算符
  * 如果表达式所表示的比较关系成立则值为真（True），否则为假（False），在C语言中分别用`int`型的1和0表示
  * `==`，`！=`，`>`，`<`，`>=`，`<=`运算符的两个操作数应该是相同类型的，两边都是整型或者都是浮点型可以做比较，但两个字符串不能做比较
  * ==和!=称为相等性运算符（Equality Operator），其余四个称为关系运算符（Relational Operator），相等性运算符的优先级低于关系运算符

* 和`if`语句相关的语法规则如下：

  语句 → if (控制表达式) 语句
  语句 → { 语句列表 }
  语句 → ;

* 在C语言中，任何允许出现语句的地方既可以是由;号结尾的一条语句，也可以是由{}括起来的若干条语句或声明组成的语句块（Statement Block），语句块和上一章介绍的函数体的语法相同

* 在C语言中一个单独的;号表示一条空语句（Null Statement）。

* **语句块中也可以定义局部变量**

  ```c
  void foo(void)
  {
  	int i = 0;
  	{
  		int i = 1;
  		int j = 2;
  		printf("i=%d, j=%d\n", i, j);
  	}
  	printf("i=%d\n", i); /* cannot access j here */
  }
  ```
  
  * 语句块中的变量`i`和函数的局部变量`i`是两个不同的变量，因此两次打印的`i`值是不同的
  * 语句块中的变量`j`在退出语句块之后就没有了，因此最后一行的`printf`不能打印变量`j`
  * 语句块可以用在任何允许出现语句的地方，不一定非得用在`if`语句中，单独使用语句块通常是为了定义一些比函数的局部变量更“局部”的变量

###  习题

* 问：在数学中`a<b<c`表示`b`既大于`a`又小于`c`，但作为C语言表达式却不是这样。以上几种运算符都是左结合的，问这个表达式应如何求值、

* 答：

* 问：以下程序段编译能通过，执行也不出错，但是执行结果不正确（根据[第 3 节 “程序的调试”](http://akaedu.github.io/book/ch01s03.html#intro.debug)的定义，这是一个语义错误），请分析一下哪里错了。还有，既然错了为什么编译能通过呢？

  ```c
  int x = -1;
  if (x > 0);
  	printf("x is positive.\n");
  ```

* 答：

##  十六、if/else语句

* C语言规定，*`else`总是和它上面最近的一个`if`配对*

  **Dangling-else问题：类似`if (A) if (B) C; else D;`形式的语句怎么理解呢？**可以理解成

  ```c
  //这是错的
  if (A)
  	if (B)
  		C;
  else
  	D;
  ```

  也可以理解成

  ```c
  //这是对的
  if (A)
  	if (B)
  		C;
  	else
  		D;
  ```

###  其他小知识点

* %运算符的结果总是与被除数同号

* 把语句封装成函数的基本步骤是：**把语句放到函数体中，把变量改成函数的参数**

* 浮点型的精度有限，不适合用==运算符做精确比较

###  问题

* 问：运算符的结果总是与被除数同号，为什么
* 答：
* 问：写两个表达式，分别取整型变量`x`的个位和十位
* 答：
* 问：写一个函数，参数是整型变量`x`，功能是打印`x`的个位和十位
* 答：

##  十七、布尔代数

* 布尔代数（Boolean Algebra）：关于逻辑运算的数学体系

* > 真和假用1和0表示，AND用*号表示，OR用+号表示（从真值表可以看出AND和OR运算确实有点像乘法和加法运算），NOT用¬表示，变量`x`、`y`、`z`的值可能是0也可能是1。
  >
  > ¬¬x=x
  >
  > x*0=0
  > x+1=1
  >
  > x*1=x
  > x+0=x
  >
  > x*x=x
  > x+x=x
  >
  > x*¬x=0
  > x+¬x=1
  >
  > x*y=y*x
  > x+y=y+x
  >
  > x*(y*z)=(x*y)*z
  > x+(y+z)=(x+y)+z
  >
  > x*(y+z)=x*y+x*z
  > x+y*z=(x+y)*(x+z)
  >
  > x+x*y=x
  > x*(x+y)=x
  >
  > x*y+x*¬y=x
  > (x+y)*(x+¬y)=x
  >
  > ¬(x*y)=¬x+¬y
  > ¬(x+y)=¬x*¬y
  >
  > x+¬x*y=x+y
  > x*(¬x+y)=x*y
  >
  > x*y+¬x*z+y*z=x*y+¬x*z
  > (x+y)*(¬x+z)*(y+z)=(x+y)*(¬x+z)



###  问题

* 问：

* 把代码段

  ```c
  if (x > 0 && x < 10);
  else
  	printf("x is out of range.\n");
  ```

  改写成下面这种形式：

  ```c
  if (____ || ____)
  	printf("x is out of range.\n");
  ```

  ____应该怎么填？

* 答：

* 问：

* 把代码段：

  ```c
  if (x > 0)
  	printf("Test OK!\n");
  else if (x <= 0 && y > 0)
  	printf("Test OK!\n");
  else
  	printf("Test failed!\n");
  ```

  改写成下面这种形式：

  ```c
  if (____ && ____)
  	printf("Test failed!\n");
  else
  	printf("Test OK!\n");
  ```

  ____应该怎么填？

* 答：

* 问：

* 有这样一段代码：

  ```c
  if (x > 1 && y != 1) {
  	...
  } else if (x < 1 && y != 1) {
  	...
  } else {
  	...
  }
  ```

  要进入最后一个`else`，x和y需要满足条件____ || ____。这里应该怎么填？

* 答：

* 问：

* 以下哪一个if判断条件是多余的可以去掉？这里所谓的“多余”是指，某种情况下如果本来应该打印`Test OK!`，去掉这个多余条件后仍然打印`Test OK!`，如果本来应该打印`Test failed!`，去掉这个多余条件后仍然打印`Test failed!`。

  ```c
  if (x<3 && y>3)
  	printf("Test OK!\n");
  else if (x>=3 && y>=3)
  	printf("Test OK!\n");
  else if (z>3 && x>=3)
  	printf("Test OK!\n");
  else if (z<=3 && y>=3)
  	printf("Test OK!\n");
  else
  	printf("Test failed!\n");
  ```

* 答：

##  十八、switch分支语句

* `switch`语句可以产生具有多个分支的控制流程。它的格式是：

  switch (控制表达式) {
  case 常量表达式： 语句列表
  case 常量表达式： 语句列表
  ...
  default： 语句列表
  }

* `case`后面跟表达式的必须是常量表达式，这个值和全局变量的初始值一样必须在编译时计算出来

* 浮点型不适合做精确比较，所以C语言规定`case`后面跟的必须是整型常量表达式

* 进入`case`后如果没有遇到`break`语句就会一直往下执行，后面其它`case`或`default`分支的语句也会被执行到，直到遇到`break`，或者执行到整个`switch`语句块的末尾

* 通常每个`case`后面都要加上`break`语句，但有时会故意不加`break`来利用这个特性，例如：

  **例 4.2. 缺break的switch语句**

  ![img](./images_学习笔记/cond.switch2.png)

* switch不是必不可缺的 ，可用一组`if ... else if ... else if ... else ...`代替
* 用`switch`语句会使代码更清晰
* 有时候编译器会对`switch`语句进行整体优化，使它比等价的`if/else`语句所生成的指令效率更高

##  十九、return语句

* 作用：提供整个函数的返回值，并结束当前函数返回调用它的地方

* **在没有返回值的函数中也可以使用`return`语句**，例如当检查到一个错误时提前结束当前函数的执行并返回：

  ```c
  #include <math.h>
  
  void print_logarithm(double x)
  {
  	if (x <= 0.0) {
  		printf("Positive numbers only, please.\n");
  		return;
  	}
  	printf("The log of x is %f", log(x));
  }
  ```

* 函数的返回值应该这样理解：**函数返回一个值相当于定义一个和返回值类型相同的临时变量并用`return`后面的表达式来初始化**
* **函数的返回值不是左值，或者说函数调用表达式不能做左值**
* 写带有`return`语句的函数时要小心检查所有的代码路径（Code Path）。有些代码路径在任何条件下都执行不到，这称为Dead Code
* **对程序中所有可能的情况分析得不够全面将导致漏掉一些代码路径，导致安静地退出函数，什么也不返回，C语言对于这种情况会返回什么结果是未定义的，通常返回不确定的值**

###  习题

* 问：编写一个布尔函数`int is_leap_year(int year)`，判断参数`year`是不是闰年。如果某年份能被4整除，但不能被100整除，那么这一年就是闰年，此外，能被400整除的年份也是闰年。
* 答：
* 问：编写一个函数`double myround(double x)`，输入一个小数，将它四舍五入。例如`myround(-3.51)`的值是-4.0，`myround(4.49)`的值是4.0。可以调用`math.h`中的库函数`ceil`和`floor`实现这个函数。
* 答：



##  二十、增量式开发

* **尽可能复用（Reuse）以前写的代码，避免写重复的代码**
* 解决问题的过程是把大的问题分成小的问题，小的问题再分成更小的问题，这个过程在代码中的体现就是函数的分层设计（Stratify）
* 上层函数通过调用底层函数来解决更大的问题，底层和上层函数都可以被更上一层的函数调用，最终所有的函数都直接或间接地被`main`函数调用
* 增量式开发：每写一行代码，验证，再继续编写
* 程序调试工具`gdb``
* ``printf`这个最原始的办法仍然是最直接、最有效的

##  二十一、递归

* 定义：自己调用自己，有最关键的基础条件（Base Case）

  * 没有基础条件的递归称为无穷递归
  * **写递归函数时一定要记得写Base Case，否则这个函数就会永远调用下去，直到操作系统为程序预留的栈空间耗尽程序崩溃（段错误）为止**

* **循环和递归是等价的**

* 栈（Stack）

* Leap of Faith

* “表达式”就是递归定义的：

  *表达式* → *表达式*(参数列表)
  参数列表 → *表达式*, *表达式*, ...

* “语句”也是递归定义的：

  *语句* → if (控制表达式) *语句*

###  习题

* 问：编写递归函数求两个正整数`a`和`b`的最大公约数（GCD，Greatest Common Divisor），使用Euclid算法：

  1. 如果`a`除以`b`能整除，则最大公约数是`b`。
  2. 否则，最大公约数等于`b`和`a%b`的最大公约数。

  Euclid算法是很容易证明的，请读者自己证明一下为什么这么算就能算出最大公约数。最后，修改你的程序使之适用于所有整数，而不仅仅是正整数。

* 答：

* 问：编写递归函数求Fibonacci数列的第`n`项，这个数列是这样定义的：

  fib(0)=1
  fib(1)=1
  fib(n)=fib(n-1)+fib(n-2)

  上面两个看似毫不相干的问题之间却有一个有意思的联系：

  - Lamé定理

    如果Euclid算法需要k步来计算两个数的GCD，那么这两个数之中较小的一个必然大于等于Fibonacci数列的第k项。

  感兴趣的读者可以参考[[SICP\]](http://akaedu.github.io/book/bi01.html#bibli.sicp)第1.2节的简略证明。

* 答：

##  二十二、while语句

* 迭代（Iteration）：重复反馈过程的活动，其目的通常是为了逼近所需目标或结果。每一次对过程的重复称为一次“迭代”，而每一次迭代得到的结果会作为下一次迭代的初始值
* while语句语法：语句 → while (控制表达式) 语句
* 循环（Loop）：重复多次执行“判断控制表达式的值，为真时执行子语句”的控制流程
* 子语句称为**循环体**
* 累加器（Accumulator）：把每次循环的中间结果累积起来，循环结束后得到的累积值就是最终结果
* 循环变量（Loop Variable）：在循环中被改变且在控制表达式中要检测值的变量起控制循环次数的作用
* 函数式编程（Functional Programming）：在整个递归调用过程中，虽然分配和释放了很多变量，但所有变量都只在初始化时赋值，没有任何变量的值发生过改变
* 命令式编程（Imperative Programming）：在整个循环过程中，循环变量和累加器未被释放过，但内部存储的值多次发生改变，以获得最终结果
* **给变量多次赋值时要格外小心，在代码中多次读写同一变量应该以一种一致的方式进行**
* 无限循环（Infinite Loop）或者叫死循环

###  习题

* 问：3x+1问题
* 答：
* 问：用循环解决[第 3 节 “递归”](http://akaedu.github.io/book/ch05s03.html#func2.recursion)的所有习题，体会递归和循环这两种不同的思路
* 答：
* 问：编写程序数一下1到100的所有整数中出现多少次数字9。在写程序之前先把这些问题考虑清楚：
  1. 这个问题中的循环变量是什么？
  2. 这个问题中的累加器是什么？用加法还是用乘法累积？
  3. 在[第 2 节 “if/else语句”](http://akaedu.github.io/book/ch04s02.html#cond.ifelse)的习题1写过取一个整数的个位和十位的表达式，这两个表达式怎样用到程序中？
* 答：

##  二十三、do/while语句

* `do/while`语句的语法是：

  语句 → do 语句 while (控制表达式);

* while与do/while的区别：`while`语句先测试控制表达式的值再执行循环体，而`do/while`语句先执行循环体再测试控制表达式的值。

  * 即while可能一次也不执行，do/while至少执行一次循环体

* **写循环一定要注意循环即将结束时控制表达式的临界条件是否准确**

##  二十四、for语句

* `for`语句的语法是：

  for (控制表达式1; 控制表达式2; 控制表达式3) 语句

  * 控制表达式1和3都可以为空，**控制表达式2是必不可少的**
  * `for (;1;) {...}`等价于`while (1) {...}`死循环
  * C语言规定，如果控制表达式2为空，则认为控制表达式2的值为真，因此死循环也可以写成`for (;;) {...}`

*  for 循环的控制流：[C for 循环 | 菜鸟教程 (runoob.com)](https://www.runoob.com/cprogramming/c-for-loop.html)

  1. **init** 会首先被执行，且只会执行一次。这一步允许您声明并初始化任何循环控制变量。您也可以不在这里写任何语句，只要有一个分号出现即可。
  2. 接下来，会判断 **condition**。如果为真，则执行循环主体。如果为假，则不执行循环主体，且控制流会跳转到紧接着 for 循环的下一条语句。
  3. 在执行完 for 循环主体后，控制流会跳回上面的 **increment** 语句。该语句允许您更新循环控制变量。该语句可以留空，只要在条件后有一个分号出现即可。
  4. 条件再次被判断。如果为真，则执行循环，这个过程会不断重复（循环主体，然后增加步值，再然后重新判断条件）。在条件变为假时，for 循环终止。

  ![C 中的 for 循环](./images_学习笔记\for控制流流程图.jpg)

* 前缀`++`，`--`和后缀`++`，`--`的区别

  > 如果把`i++`这个表达式看作一个函数调用，传入一个参数返回一个值，返回值就等于参数值（而不是参数值加1），此外也产生一个Side Effect，就是把变量`i`的值增加了1，它和`++i`的区别就在于返回值不同。同理，`--i`返回减1之后的值，而`i--`返回减1之前的值，但这两个表达式都产生同样的Side Effect，就是把变量`i`的值减了1。

  * `++`称为前缀自增运算符（Prefix Increment Operator）
  * `--`前缀自减运算符（Prefix Decrement Operator）
  * `++`后缀自增运算符（Postfix Increment Operator）
  * `--`后缀自减运算符（Postfix Decrement Operator）

* 问题：`a+++++b`这个表达式如何理解？应该理解成`a++ ++ +b`还是`a++ + ++b`，还是`a + ++ ++b`呢？

  * 应该按第一种方式理解

  * **编译的过程分为词法解析和语法解析两个阶段，在词法解析阶段，编译器总是从前到后找最长的合法Token**

  * 解析

    > 把这个表达式从前到后解析，变量名`a`是一个Token，`a`后面有两个以上的+号，在C语言中一个+号是合法的Token（可以是加法运算符或正号），两个+号也是合法的Token（可以是自增运算符），根据最长匹配原则，编译器绝不会止步于一个+号，而一定会把两个+号当作一个Token。再往后解析仍然有两个以上的+号，所以又是一个++运算符。再往后解析只剩一个+号了，是加法运算符。再往后解析是变量名`b`。词法解析之后进入下一阶段语法解析，`a`是一个表达式，表达式++还是表达式，表达式再++还是表达式，表达式再+b还是表达式，语法上没有问题。最后编译器会做一些基本的语义分析，这时就有问题了，++运算符要求操作数能做左值，`a`能做左值所以`a++`没问题，但表达式`a++`的值只能做右值，不能再++了，所以最终编译器会报错。

###  问题

* 问题：`a+++++b`这个表达式如何理解？应该理解成`a++ ++ +b`还是`a++ + ++b`，还是`a + ++ ++b`呢？**是否真的如分析所说，为第一种，且编译器会报错**

##  二十五、break和cotinue语句

* **在多重循环中， break和continue只对当层循环有用，对外层循环没有影响。**

* break语句：

  * 用于跳出switch语句块
  * 跳出循环体（`break`只能跳出最内层的循环）

* continue语句：终止当前循环后又回到循环体的开头准备执行下一次循环

  * continue语句不能直接用于switch语句但可用于嵌入循环语句中的switch语句

    ~~~C
    //编译器报错
    int a=1;
    	switch(a)
    	{
    		case 1:
    			printf("111");
    			continue;
    		case 2:
    			printf("222");
    		default:
    			continue;
    	}
    
    //可跳出switch语句
    int a=1, i;
    	for(i=0;i<10;i++)
    	{
    		switch(a)
    		{
    			case 1:
    				printf("111\n");
    				continue;
    			case 2:
    				printf("222\n");
    			default:
    				continue;
    		}
    	}
    
    原文链接：https://blog.csdn.net/qq_42942881/article/details/104542233
    ~~~

* 对于`while`循环和`do/while`循环，执行`continue`语句之后测试控制表达式，如果值为真则继续执行下一次循环

* 对于`for`循环，执行`continue`语句之后首先计算控制表达式3，然后测试控制表达式2，如果值为真则继续执行下一次循环

###  问题

* 问：为何break语句可以跳出switch语句，而continue不行？根本区别是什么
* 答：
* 问：continue语句跳出嵌入循环体的switch语句是真的跳出switch语句还是在跳出循环体时顺便跳出switch，本质还是跳出循环体？
* 答：
* 问：求素数这个程序只是为了说明`break`和`continue`的用法才这么写的，其实完全可以不用`break`和`continue`，请读者修改一下控制流程，去掉`break`和`continue`而保持功能不变。
* 答：
* 问：上一节讲过怎样把`for`循环改写成等价的`while`循环，但也提到如果循环体中有`continue`语句这两种形式就不等价了，想一想为什么不等价了？
* 答：

##  二十六、嵌套循环

* C 语言中 **嵌套 for 循环** 语句的语法：[C 嵌套循环 | 菜鸟教程 (runoob.com)](https://www.runoob.com/cprogramming/c-nested-loops.html)

  ```c
  for (initialization; condition; increment/decrement)
  {
      statement(s);
      for (initialization; condition; increment/decrement)
      {
          statement(s);
          ... ... ...
      }
      ... ... ...
  }
  ```

  流程图：

  ![img](./images_学习笔记\c_for嵌套循环流程图.svg)

* C 语言中 **嵌套 while 循环** 语句的语法：

  ```c
  while (condition1)
  {
      statement(s);
      while (condition2)
      {
          statement(s);
          ... ... ...
      }
      ... ... ...
  }
  ```

  流程图：

  ![img](./images_学习笔记\c_while嵌套循环流程图.svg)

* C 语言中 **嵌套 do...while 循环** 语句的语法：

  ```c
  do
  {
      statement(s);
      do
      {
          statement(s);
          ... ... ...
      }while (condition2);
      ... ... ...
  }while (condition1);
  ```

  流程图：

  ![img](./images_学习笔记\c_do_while嵌套循环流程图.svg)

* 关于嵌套循环有一点值得注意，您可以在任何类型的循环内嵌套其他任何类型的循环。比如，一个 for 循环可以嵌套在一个 while 循环内，反之亦然。

###  习题

使用for、while、do/while三种循环实现下列习题

* 上面打印的小九九有一半数据是重复的，因为8*9和9*8的结果一样。请修改程序打印这样的小九九：

  ```c
  1	
  2	4	
  3	6	9	
  4	8	12	16	
  5	10	15	20	25	
  6	12	18	24	30	36	
  7	14	21	28	35	42	49	
  8	16	24	32	40	48	56	64	
  9	18	27	36	45	54	63	72	81
  ```

* 编写函数`diamond`打印一个菱形。如果调用`diamond(3, '*')`则打印：

  ```c
  	*
  *	*	*
  	*
  ```

  如果调用`diamond(5, '+')`则打印：

  ```c
  		+
  	+	+	+
  +	+	+	+	+
  	+	+	+
  		+
  ```

  如果用偶数做参数则打印错误提示。

##  二十七、goto语句和标号

###  goto语句

* `goto`语句：实现无条件跳转

* 使用场景：在一个嵌套循环中遇到某个错误条件需要立即跳出最外层循环做出错处理

  ```c
  for (...)
  	for (...) {
  		...
  		if (出现错误条件)
  			goto error;
  	}
  error:
  	出错处理;
  ```

  * `error:`叫做标号（Label）。任何语句前面都可以加若干个标号，每个标号的命名也要遵循标识符的命名规则
  * **在任何其它场合都不要轻易考虑使用`goto`语句。**有些编程语言（如C++）中有异常（Exception）处理的语法，可以代替`goto`和`setjmp/longjmp`的这种用法。

* `goto`只能跳转到同一个函数中的某个标号处，而不能跳到别的函数中

* 

* `goto`语句不是必须存在的，显然可以用别的办法替代，比如上面的代码段可以改写为：

  ```c
  int cond = 0; /* bool variable indicating error condition */
  for (...) {
  	for (...) {
  		...
  		if (出现错误条件) {
  			cond = 1;
  			break;
  		}
  	}
  	if (cond)
  		break;
  }
  if (cond)
  	出错处理;
  ```

###  标号

* `case`和`default`后面也要跟冒号（:号，Colon），事实上它们是两种特殊的标号。和标号有关的语法规则如下：

  语句 → 标识符: 语句
  语句 → case 常量表达式: 语句
  语句 → default: 语句

  ###  有趣的知识点扩展

* 有兴趣的读者可以在网上查找有关Duff's Device的资料，Duff's Device是一段很有意思的代码，正是利用“`switch`的语句块和循环结构的语句块没有本质区别”这一点实现了一个巧妙的代码优化
* C标准库函数`setjmp`和`longjmp`配合起来可以实现函数间的跳转，但只能从被调用的函数跳回到它的直接或间接调用者（同时从栈空间弹出一个或多个栈帧），而不能从一个函数跳转到另一个和它毫不相干的函数中。`setjmp/longjmp`函数主要也是用于出错处理，比如函数`A`调用函数`B`，函数`B`调用函数`C`，如果在`C`中出现某个错误条件，使得函数`B`和`C`继续执行下去都没有意义了，可以利用`setjmp/longjmp`机制快速返回到函数`A`做出错处理，本书不详细介绍这种机制，有兴趣的读者可参考[[APUE2e\]](http://akaedu.github.io/book/bi01.html#bibli.apue)。

##  二十八、复合类型与结构体

* 基本类型（Primitive Type）：最基本的、不可再分的数据类型

* 复合类型（Compound Type）：根据语法规则由基本类型组合而成的类型

* [[SICP\]](http://akaedu.github.io/book/bi01.html#bibli.sicp)指出，在学习一门编程语言时要特别注意以下三个方面：

  1. 这门语言提供了哪些Primitive，比如基本类型，比如基本运算符、表达式和语句。
  2. 这门语言提供了哪些组合规则，比如基本类型如何组成复合类型，比如简单的表达式和语句如何组成复杂的表达式和语句。
  3. 这门语言提供了哪些抽象机制，包括数据抽象（Data Abstraction）和过程抽象（Procedure Abstraction）。

* 结构体定义方式：[C 结构体 | 菜鸟教程 (runoob.com)](https://www.runoob.com/cprogramming/c-structures.html)

* .运算符（.号，Period）可用于访问结构体成员

* 

  ```c
  double x = 3.0;
  struct complex_struct z1 = { x, 4.0, }; /* z1.x=3.0, z1.y=4.0 */
  struct complex_struct z2 = { 3.0, }; /* z2.x=3.0, z2.y=0.0 */
  struct complex_struct z3 = { 0 }; /* z3.x=0.0, z3.y=0.0 */
  ```

  * 如果Initializer中的数据比结构体的成员多，编译器会报错，但如果只是末尾多个逗号则不算错

  * 如果Initializer中的数据比结构体的成员少，未指定的成员将用0来初始化，就像未初始化的全局变量一样。

  * **`z1`必须是局部变量才能用另一个变量`x`的值来初始化它的成员，如果是全局变量就只能用常量表达式来初始化**

  * {}这种语法不能用于结构体的赋值，例如这样是错误的：

    ```c
    struct complex_struct z1;
    z1 = { 3.0, 4.0 };
    ```

    以前我们初始化基本类型的变量所使用的Initializer都是表达式，表达式当然也可以用来赋值，但现在这种由{}括起来的Initializer并不是表达式，所以不能用来赋值[[14](http://akaedu.github.io/book/ch07s01.html#ftn.id2730593)]

    ###  困惑

* Initializer的语法总结如下：

  Initializer → 表达式
  Initializer → { 初始化列表 } 
  初始化列表 → Designated-Initializer, Designated-Initializer, ...
  （最后一个Designated-Initializer末尾可以有一个多余的,号）
  Designated-Initializer → Initializer
  Designated-Initializer → .标识符 = Initializer
  Designated-Initializer → [常量表达式] = Initializer

* Designated Initializer是C99引入的新特性，用于初始化稀疏（Sparse）结构体和稀疏数组很方便。有些时候结构体或数组中只有某一个或某几个成员需要初始化，其它成员都用0初始化即可，用Designated Initializer语法可以针对每个成员做初始化（Memberwise Initialization），很方便。例如：

  ```c
  struct complex_struct z1 = { .y = 4.0 }; /* z1.x=0.0, z1.y=4.0 */
  ```

* 结构体类型用在表达式中有很多限制，不像基本类型那么自由，比如+ - * /等算术运算符和&& || !等逻辑运算符都不能作用于结构体类型，`if`语句、`while`语句中的控制表达式的值也不能是结构体类型。

* 严格来说，可以做算术运算的类型称为**算术类型（Arithmetic Type）**，算术类型包括整型和浮点型。

* 可以表示零和非零，可以参与逻辑与、或、非运算或者做控制表达式的类型称为**标量类型（Scalar Type）**，标量类型包括算术类型和以后要讲的指针类型

* ```c
  struct complex_struct z1 = { 3.0, 4.0 };
  struct complex_struct z2 = z1;
  z1 = z2;
  ```

  * 结构体变量之间可以使用赋值运算符
  * 可以用一个结构体变量初始化另一个结构体变量（**`z2`必须是局部变量才能用变量`z1`的值来初始化**）

* 结构体变量之间可以相互赋值和初始化，也就可以当作函数的参数和返回值来传递：

  ```c
  struct complex_struct add_complex(struct complex_struct z1, struct complex_struct z2)
  {
  	z1.x = z1.x + z2.x;
  	z1.y = z1.y + z2.y;
  	return z1;
  }
  ```

  这个函数实现了两个复数相加，如果在`main`函数中这样调用：

  ```c
  struct complex_struct z = { 3.0, 4.0 };
  z = add_complex(z, z);
  ```

  * 那么调用传参的过程如下图所示：

  **图 7.2. 结构体传参**

  ![结构体传参](./images_学习笔记\struct.parameter.png)
  * 变量`z`在`main`函数的栈帧上，参数`z1`和`z2`在`add_complex`函数的栈帧上，`z`的值分别赋给`z1`和`z2`。在这个函数里，`z2`的实部和虚部被累加到`z1`中，然后`return z1;`可以看成是：

    1. 用`z1`初始化一个临时变量。
    2. 函数返回并释放栈帧。
    3. 把临时变量的值赋给变量`z`，释放临时变量。

    由.运算符组成的表达式能不能做左值取决于.运算符左边的表达式能不能做左值。在上面的例子中，`z`是一个变量，可以做左值，因此表达式`z.x`也可以做左值，但表达式`add_complex(z, z).x`只能做右值而不能做左值，因为表达式`add_complex(z, z)`不能做左值。

##  二十九、数据抽象

* 构建复数数据结构，并设计复数加减乘除的计算方式[2. 数据抽象 (akaedu.github.io)](http://akaedu.github.io/book/ch07s02.html)

* 这个例子中，复数存储表示层和复数运算层称为抽象层（Abstraction Layer），从底层往上层来看，复数越来越抽象了，把所有这些层组合在一起就是一个完整的系统。

  ![数据抽象](./images_学习笔记\struct.abstraction.png)

* **组合使得系统可以任意复杂，而抽象使得系统的复杂性是可以控制的，任何改动都只局限在某一层，而不会波及整个系统**。著名的计算机科学家Butler Lampson说过：“All problems in computer science can be solved by another level of indirection.”这里的indirection其实就是abstraction的意思。

###  习题

* 问：在本节的基础上实现一个打印复数的函数，打印的格式是x+yi，如果实部或虚部为0则省略，例如：1.0、-2.0i、-1.0+2.0i、1.0-2.0i。最后编写一个`main`函数测试本节的所有代码。想一想这个打印函数应该属于上图中的哪一层？

* 答：

* 问：实现一个用分子分母的格式来表示有理数的结构体`rational`以及相关的函数，`rational`结构体之间可以做加减乘除运算，运算的结果仍然是`rational`。测试代码如下：

  ```c
  int main(void)
  {
  	struct rational a = make_rational(1, 8); /* a=1/8 */
  	struct rational b = make_rational(-1, 8); /* b=-1/8 */
  	print_rational(add_rational(a, b));
  	print_rational(sub_rational(a, b));
  	print_rational(mul_rational(a, b));
  	print_rational(div_rational(a, b));
  
  	return 0;
  }
  ```

  注意要约分为最简分数，例如1/8和-1/8相减的打印结果应该是1/4而不是2/8，可以利用[第 3 节 “递归”](http://akaedu.github.io/book/ch05s03.html#func2.recursion)练习题中的Euclid算法来约分。在动手编程之前先思考一下这个问题实现了什么样的数据抽象，抽象层应该由哪些函数组成。

* 答：

##  三十、数据类型标志

* > 比如先前已经采集了一些数据存在计算机中，有些数据是以极座标存储的，有些数据是以直角座标存储的，如果要把这些数据都存到`complex_struct`结构体中怎么办？

  * 方法一：规定`complex_struct`结构体采用直角座标格式，直角座标的数据可以直接存入`complex_struct`结构体，而极座标的数据先转成直角座标再存

    * 缺点：由于浮点数的精度有限，转换总是会损失精度的

  * 方法二：`complex_struct`结构体由一个数据类型标志和两个浮点数组成，如果数据类型标志为0，那么两个浮点数就表示直角座标，如果数据类型标志为1，那么两个浮点数就表示极座标

    * 优点：直角座标和极座标的数据都可以适配（Adapt）到`complex_struct`结构体中，无需转换和损失精度
    * 缺点：额外增加一个数据成员

  * ```c
    enum coordinate_type { RECTANGULAR, POLAR };
    struct complex_struct {
    	enum coordinate_type t;
    	double a, b;
    };
    ```

    

* 结构体的成员名和变量名不在同一命名空间中，但枚举的成员名却和变量名在同一命名空间中，所以会出现命名冲突

###  习题

* 问：本节只给出了`make_from_real_img`和`make_from_mag_ang`函数的实现，请读者自己实现`real_part`、`img_part`、`magnitude`、`angle`这些函数

* 答：

* 问：编译运行下面这段程序：

  ```
  #include <stdio.h>
  
  enum coordinate_type { RECTANGULAR = 1, POLAR };
  
  int main(void)
  {
  	int RECTANGULAR;
  	printf("%d %d\n", RECTANGULAR, POLAR);
  	return 0;
  }
  ```

  结果是什么？并解释一下为什么是这样的结果。

* 答：

##  三十一、嵌套结构体

* 结构体也是一种递归定义：结构体的成员具有某种数据类型，而结构体本身也是一种数据类型。换句话说，结构体的成员可以是另一个结构体，即结构体可以嵌套定义。例如我们在复数的基础上定义复平面上的线段：

  ```c
  struct segment {
  	struct complex_struct start;
  	struct complex_struct end;
  };
  ```

* 初始化方式：

  * 嵌套地初始化，例如：

    ```
    struct segment s = {{ 1.0, 2.0 }, { 4.0, 6.0 }};
    ```

  * 也可以平坦（Flat）地初始化。例如：

    ```c
    struct segment s = { 1.0, 2.0, 4.0, 6.0 };
    ```

  * 甚至可以把两种方式混合使用（这样可读性很差，应该避免）：

    ```c
    struct segment s = {{ 1.0, 2.0 }, 4.0, 6.0 };
    ```

  * 利用C99的新特性也可以做Memberwise Initialization，例如[[15](http://akaedu.github.io/book/ch07s04.html#ftn.id2731613)]：

    ```c
    struct segment s = { .start.x = 1.0, .end.x = 2.0 };
    ```

* 访问嵌套结构体的成员要用到多个.运算符，例如：

  ```c
  s.start.t = RECTANGULAR;
  s.start.a = 1.0;
  s.start.b = 2.0;
  ```

##  三十二、数值的基本概念

* 数组（Array）也是一种复合数据类型，它由一系列相同类型的元素（Element）组成

* **数组和结构体可以相互嵌套使用，即结构体类型数组和包含数组成员的结构体**

* 所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。

* 数组类型的长度应该用一个整数常量表达式来指定[[16](http://akaedu.github.io/book/ch08s01.html#ftn.id2733250)]。数组中的元素通过下标（或者叫索引，Index）来访问。例如前面定义的由4个`int`型元素组成的数组`count`图示如下：

  **图 8.1. 数组count**

  ![数组count](./images_学习笔记\array.count.png)

  整个数组占了4个`int`型的存储单元，存储单元用小方框表示，里面的数字是存储在这个单元中的数据（假设都是0），而框外面的数字是下标，这四个单元分别用`count[0]`、`count[1]`、`count[2]`、`count[3]`来访问

* 在**定义**数组`int count[4];`时，方括号（Bracket）中的数字4表示数组的**长度**，而在**访问数组**时，方括号中的数字表示访问数组的**第几个**元素。**数组元素是从“第0个”开始数的**

* 这种数组下标的表达式不仅可以表示存储单元中的值，也可以表示存储单元本身，也就是说可以做左值

* C编译器并不检查`count[-1]`或是`count[100]`这样的访问越界错误，编译时能顺利通过，所以属于运行时错误

* **数组可和结构体一样进行初始化，未赋初值的元素也是用0来初始化，但数组不能相互赋值或初始化**

* **不能用数组类型作为函数的参数或返回值**

* **数组类型做右值使用时，自动转换成指向数组首元素的指针**

* 如果定义数组的同时初始化它，也可以不指定数组的长度

* 遍历（Traversal）：通过循环把数组中的每个元素依次访问一遍

  * ```c
    #include <stdio.h>
    
    int main(void)
    {
    	int count[4] = { 3, 2, }, i;
    
    	for (i = 0; i < 4; i++)
    		printf("count[%d]=%d\n", i, count[i]);
    	return 0;
    }
    ```

###  习题

* 问：*数组类型做右值使用时，自动转换成指向数组首元素的指针*
* 答：

##  三十三、数组应用实例：统计随机数

###  小知识点

* C标准库中生成伪随机数的是`rand`函数，使用这个函数需要包含头文件`stdlib.h`，它没有参数，返回值是一个介于0和`RAND_MAX`之间的接近均匀分布的整数。`RAND_MAX`是该头文件中定义的一个常量，在不同的平台上有不同的取值
* 编译器的工作分为两个阶段，先是预处理（Preprocess）阶段，然后才是编译阶段，用`gcc`的`-E`选项可以看到预处理之后、编译之前的程序。用`cpp main.c`命令也可以达到同样的效果，只做预处理而不编译，`cpp`表示C preprocessor
* 在定义数组时直接写成`int a[20];`，在每个循环中也直接使用20这个值，这称为硬编码（Hard coding）。**写代码时应尽可能避免硬编码**

###  习题

* 问：生成一列0~9的随机数保存在数组中，然后统计其中每个数字出现的次数并打印，检查这些数字的随机性如何。

* 答：

* 问：#define和枚举变量的区别

* 答：

* 问：试试看把[第 3 节 “数据类型标志”](http://akaedu.github.io/book/ch07s03.html#struct.datatag)习题2的程序改成下面这样是什么结果。

  ```c
  #include <stdio.h>
  #define RECTANGULAR 1
  #define POLAR 2
  
  int main(void)
  {
  	int RECTANGULAR;
  	printf("%d %d\n", RECTANGULAR, POLAR);
  	return 0;
  }
  ```

* 答：

* 问：用`rand`函数生成[10, 20]之间的随机整数，表达式应该怎么写？

* 答：

##  三十四、 数组应用实例：直方图

* 统计一列0~9的随机数，打印每个数字出现的次数，像这样的统计结果称为直方图（Histogram）

* C标准库允许我们自己指定一个初值，然后在此基础上生成伪随机数，这个初值称为Seed，可以用`srand`函数指定Seed。通常我们通过别的途径得到一个不确定的数作为Seed，例如调用`time`函数得到当前系统时间距1970年1月1日00:00:00[[18](http://akaedu.github.io/book/ch08s03.html#ftn.id2734350)]的秒数，然后传给`srand`：

  ```c
  srand(time(NULL));
  ```

###  习题

* 问：补完本节直方图程序的`main`函数，以可视化的形式打印直方图。例如上一节统计20个随机数的结果是：

  ```c
  0  1  2  3  4  5  6  7  8  9
  
  *  *  *  *     *  *  *     *
  *     *  *     *  *  *     *
        *  *        *
                    *
                    *
  ```

* 答：

* 问：定义一个数组，编程打印它的全排列。比如定义：

  ```c
  #define N 3
  int a[N] = { 1, 2, 3 };
  ```

  则运行结果是：

  ```c
  $ ./a.out
  1 2 3 
  1 3 2 
  2 1 3 
  2 3 1 
  3 2 1 
  3 1 2 
  1 2 3
  ```

  程序的主要思路是：

  1. 把第1个数换到最前面来（本来就在最前面），准备打印1xx，再对后两个数2和3做全排列。
  2. 把第2个数换到最前面来，准备打印2xx，再对后两个数1和3做全排列。
  3. 把第3个数换到最前面来，准备打印3xx，再对后两个数1和2做全排列。

  可见这是一个递归的过程，把对整个序列做全排列的问题归结为对它的子序列做全排列的问题，注意我没有描述Base Case怎么处理，你需要自己想。你的程序要具有通用性，如果改变了`N`和数组`a`的定义（比如改成4个数的数组），其它代码不需要修改就可以做4个数的全排列（共24种排列）。

  完成了上述要求之后再考虑第二个问题：如果再定义一个常量`M`表示从`N`个数中取几个数做排列（`N == M`时表示全排列），原来的程序应该怎么改？

  最后再考虑第三个问题：如果要求从`N`个数中取`M`个数做组合而不是做排列，就不能用原来的递归过程了，想想组合的递归过程应该怎么描述，编程实现它。

* 答：

##  三十五、字符串

* 字符串可以看作一个数组，它的每个元素是字符型的，例如字符串`"Hello, world.\n"`图示如下：

  **图 8.2. 字符串**

  ![字符串](./images_学习笔记\array.string.png)

* 数组元素可以通过数组名加下标的方式访问，而字符串字面值也可以像数组名一样使用，可以加下标访问其中的字符：

  ```c
  char c = "Hello, world.\n"[0];//合法的
  ```

  但是通过下标修改其中的字符却是不允许的：

  ```c
  "Hello, world.\n"[0] = 'A';//不允许的；不合法的
  ```

* **字符串字面值还有一点和数组名类似，做右值使用时自动转换成指向首元素的指针**

* 字符串字面值是只读的，不允许修改，但用一个字符串字面值初始化的数组`str`却是可读可写的

* 如果用于初始化的字符串字面值比数组还长，比如：

  ```
  char str[10] = "Hello, world.\n";
  ```

  则数组`str`只包含字符串的前10个字符，不包含Null字符，这种情况编译器会给出警告。如果要用一个字符串字面值准确地初始化一个字符数组，最好的办法是不指定数组的长度，让编译器自己计算：

  ```
  char str[] = "Hello, world.\n";
  ```

  字符串字面值的长度包括Null字符在内一共15个字符，编译器会确定数组`str`的长度为15。

* 有一种情况需要特别注意，如果用于初始化的字符串字面值比数组刚好长出一个Null字符的长度，比如：

  ```
  char str[14] = "Hello, world.\n";
  ```

  则数组`str`不包含Null字符，并且编译器不会给出警告

* > `printf`会从数组`str`的开头一直打印到Null字符为止，Null字符本身是Non-printable字符，不打印。这其实是一个危险的信号：如果数组`str`中没有Null字符，那么`printf`函数就会访问数组越界，后果可能会很诡异：有时候打印出乱码，有时候看起来没错误，有时候引起程序崩溃。

##  三十六、多维数组

* 数组嵌套——多维数组（Multi-dimensional Array）：一个数组的元素是另外一个数组

* 定义并初始化一个二维数组：

  ```c
  int a[3][2] = { 1, 2, 3, 4, 5 };
  ```

  数组`a`有3个元素，`a[0]`、`a[1]`、`a[2]`。每个元素也是一个数组，例如`a[0]`是一个数组，它有两个元素`a[0][0]`、`a[0][1]`，这两个元素的类型是`int`，值分别是1、2，同理，数组`a[1]`的两个元素是3、4，数组`a[2]`的两个元素是5、0。如下图所示：

  **图 8.3. 多维数组**

  ![多维数组](./images_学习笔记\array.multidim.png)

  * 从概念模型上看，这个二维数组是三行两列的表格，元素的两个下标分别是行号和列号。
  * 从物理模型上看，这六个元素在存储器中仍然是连续存储的，就像一维数组一样，相当于把概念模型的表格一行一行接起来拼成一串，C语言的这种存储方式称为Row-major方式.而有些编程语言（例如FORTRAN）是把概念模型的表格一列一列接起来拼成一串存储的，称为Column-major方式。

* 数据驱动的编程（Data-driven Programming）：用数据代替了代码，例如：通过下标访问字符串组成的数组可以代替一堆`case`分支判断，这样就可以把每个`case`里重复的代码（`printf`调用）提取出来，从而又一次达到了“提取公因式”的效果

* 最简单的小游戏－－剪刀石头布：

  **例 8.5. 剪刀石头布**

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  #include <time.h>
  
  int main(void)
  {
  	char gesture[3][10] = { "scissor", "stone", "cloth" };
  	int man, computer, result, ret;
  
  	srand(time(NULL));
  	while (1) {
  		computer = rand() % 3;
  	  	printf("\nInput your gesture (0-scissor 1-stone 2-cloth):\n");
  		ret = scanf("%d", &man);
  	  	if (ret != 1 || man < 0 || man > 2) {
  			printf("Invalid input! Please input 0, 1 or 2.\n");
  			continue;
  		}
  		printf("Your gesture: %s\tComputer's gesture: %s\n", 
  			gesture[man], gesture[computer]);
  
  		result = (man - computer + 4) % 3 - 1;
  		if (result > 0)
  			printf("You win!\n");
  		else if (result == 0)
  			printf("Draw!\n");
  		else
  			printf("You lose!\n");
  	}
  	return 0;
  }
  ```

  

  0、1、2三个整数分别是剪刀石头布在程序中的内部表示，用户也要求输入0、1或2，然后和计算机随机生成的0、1或2比胜负。这个程序的主体是一个死循环，需要按Ctrl-C退出程序。以往我们写的程序都只有打印输出，在这个程序中我们第一次碰到处理用户输入的情况。我们简单介绍一下`scanf`函数的用法，到[第 2.9 节 “格式化I/O函数”](http://akaedu.github.io/book/ch25s02.html#stdlib.formatio)再详细解释。`scanf("%d", &man)`这个调用的功能是等待用户输入一个整数并回车，这个整数会被`scanf`函数保存在`man`这个整型变量里。如果用户输入合法（输入的确实是数字而不是别的字符），则`scanf`函数返回1，表示成功读入一个数据。但即使用户输入的是整数，我们还需要进一步检查是不是在0~2的范围内，写程序时对用户输入要格外小心，用户有可能输入任何数据，他才不管游戏规则是什么。

###  习题

* 问：上文剪刀石头布小游戏代码中，`(man - computer + 4) % 3 - 1`这个神奇的表达式是如何比较出0、1、2这三个数字在“剪刀石头布”意义上的大小的？
* 答：

##  三十七、缩进和空白

* 空白字符的规定

  1、关键字`if`、`while`、`for`与其后的控制表达式的(括号之间插入一个空格分隔，但括号内的表达式应紧贴括号。例如：

  ```
  while␣(1);
  ```

  2、双目运算符的两侧各插入一个空格分隔，单目运算符和操作数之间不加空格，例如`i␣=␣i␣+␣1`、`++i`、`!(i␣<␣1)`、`-x`、`&a[1]`等。

  3、后缀运算符和操作数之间也不加空格，例如取结构体成员`s.a`、函数调用`foo(arg1)`、取数组成员`a[i]`。

  4、,号和;号之后要加空格，这是英文的书写习惯，例如`for␣(i␣=␣1;␣i␣<␣10;␣i++)`、`foo(arg1,␣arg2)`。

  5、以上关于双目运算符和后缀运算符的规则并没有严格要求，有时候为了突出优先级也可以写得更紧凑一些，例如`for␣(i=1;␣i<10;␣i++)`、`distance␣=␣sqrt(x*x␣+␣y*y)`等。但是省略的空格一定不要误导了读代码的人，例如`a||b␣&&␣c`很容易让人理解成错误的优先级。

  6、由于UNIX系统标准的字符终端是24行80列的，接近或大于80个字符的较长语句要折行写，折行后用空格和上面的表达式或参数对齐，例如：

  ```c
  if␣(sqrt(x*x␣+␣y*y)␣>␣5.0
      &&␣x␣<␣0.0
      &&␣y␣>␣0.0)
  ```

  再比如：

  ```c
  foo(sqrt(x*x␣+␣y*y),
      a[i-1]␣+␣b[i-1]␣+␣c[i-1])
  ```

  7、较长的字符串可以断成多个字符串然后分行书写，例如：

  ```c
  printf("This is such a long sentence that "
         "it cannot be held within a line\n");
  ```

  C编译器会自动把相邻的多个字符串接在一起，以上两个字符串相当于一个字符串`"This is such a long sentence that it cannot be held within a line\n"`。

  8、有的人喜欢在变量定义语句中用Tab字符，使变量名对齐，这样看起来很美观。

  ```c
         →int    →a, b;
         →double →c;
  ```

* 缩进的规则

  1、要用缩进体现出语句块的层次关系，使用Tab字符缩进，不能用空格代替Tab。在标准的字符终端上一个Tab看起来是8个空格的宽度，如果你的文本编辑器可以设置Tab的显示宽度是几个空格，建议也设成8，这样大的缩进使代码看起来非常清晰。如果有的行用空格做缩进，有的行用Tab做缩进，甚至空格和Tab混用，那么一旦改变了文本编辑器的Tab显示宽度就会看起来非常混乱，所以内核代码风格规定只能用Tab做缩进，不能用空格代替Tab。

  2、`if/else`、`while`、`do/while`、`for`、`switch`这些可以带语句块的语句，语句块的{或}应该和关键字写在同一行，用空格隔开，而不是单独占一行。例如应该这样写：

  ```c
  if␣(...)␣{
         →语句列表
  }␣else␣if␣(...)␣{
         →语句列表
  }
  ```

  但很多人习惯这样写：

  ```c
  if␣(...)
  {
         →语句列表
  }
  else␣if␣(...)
  {
         →语句列表
  }
  ```

  内核的写法和[[K&R\]](http://akaedu.github.io/book/bi01.html#bibli.kr)一致，好处是不必占太多行，使得一屏能显示更多代码。这两种写法用得都很广泛，只要在同一个项目中能保持统一就可以了。

  3、函数定义的{和}单独占一行，这一点和语句块的规定不同，例如：

  ```c
  int␣foo(int␣a,␣int␣b)
  {
         →语句列表
  }
  ```

  4、`switch`和语句块里的`case`、`default`对齐写，也就是说语句块里的`case`、`default`标号相对于`switch`不往里缩进，但标号下的语句要往里缩进。例如：

  ```c
        →switch␣(c)␣{
        →case 'A':
        →       →语句列表
        →case 'B':
        →       →语句列表
        →default:
        →       →语句列表
        →}
  ```

  用于`goto`语句的自定义标号应该顶头写不缩进，而不管标号下的语句缩进到第几层。

  5、代码中每个逻辑段落之间应该用一个空行分隔开。例如每个函数定义之间应该插入一个空行，头文件、全局变量定义和函数定义之间也应该插入空行，例如：

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  
  int g;
  double h;
  
  int foo(void)
  {
         →语句列表
  }
  
  int bar(int a)
  {
         →语句列表
  }
  
  int main(void)
  {
         →语句列表
  }
  ```

  6、一个函数的语句列表如果很长，也可以根据相关性分成若干组，用空行分隔。这条规定不是严格要求，通常把变量定义组成一组，后面加空行，`return`语句之前加空行，例如：

  ```c
  int main(void)
  {
         →int    →a, b;
         →double →c;
  
         →语句组1
  
         →语句组2
  
         →return 0;
  }
  ```

##  三十八、注释

* 注释方式：

  * 单行注释应采用`/*␣comment␣*/`的形式，用空格把界定符和文字分开。

  * 多行注释最常见的是这种形式：

    ```c
    /*
    ␣*␣Multi-line
    ␣*␣comment
    ␣*/
    ```

    也有更花哨的形式：

    ```c
    /*************\
    * Multi-line  *
    * comment     *
    \*************/
    ```

* 注释场合：

  1、整个源文件的顶部注释。说明此模块的相关信息，例如文件名、作者和版本历史等，顶头写不缩进。例如内核源代码目录下的`kernel/sched.c`文件的开头：

  ```c
  /*
   *  kernel/sched.c
   *
   *  Kernel scheduler and related syscalls
   *
   *  Copyright (C) 1991-2002  Linus Torvalds
   *
   *  1996-12-23  Modified by Dave Grothe to fix bugs in semaphores and
   *              make semaphores SMP safe
   *  1998-11-19  Implemented schedule_timeout() and related stuff
   *              by Andrea Arcangeli
   *  2002-01-04  New ultra-scalable O(1) scheduler by Ingo Molnar:
   *              hybrid priority-list and round-robin design with
   *              an array-switch method of distributing timeslices
   *              and per-CPU runqueues.  Cleanups and useful suggestions
   *              by Davide Libenzi, preemptible kernel bits by Robert Love.
   *  2003-09-03  Interactivity tuning by Con Kolivas.
   *  2004-04-02  Scheduler domains code by Nick Piggin
   */
  ```

  2、函数注释。说明此函数的功能、参数、返回值、错误码等，写在函数定义上侧，和此函数定义之间不留空行，顶头写不缩进。

  3、相对独立的语句组注释。对这一组语句做特别说明，写在语句组上侧，和此语句组之间不留空行，与当前语句组的缩进一致。

  4、代码行右侧的简短注释。对当前代码行做特别说明，一般为单行注释，和代码之间至少用一个空格隔开，一个源文件中所有的右侧注释最好能上下对齐。尽管[例 2.1 “带更多注释的Hello World”](http://akaedu.github.io/book/ch02s01.html#expr.morehelloworld)讲过注释可以穿插在一行代码中间，但不建议这么写。内核源代码目录下的`lib/radix-tree.c`文件中的一个函数包含了上述三种注释：

  ```c
  /**
   *      radix_tree_insert    -    insert into a radix tree
   *      @root:          radix tree root
   *      @index:         index key
   *      @item:          item to insert
   *
   *      Insert an item into the radix tree at position @index.
   */
  int radix_tree_insert(struct radix_tree_root *root,
                          unsigned long index, void *item)
  {
          struct radix_tree_node *node = NULL, *slot;
          unsigned int height, shift;
          int offset;
          int error;
  
          /* Make sure the tree is high enough.  */
          if ((!index && !root->rnode) ||
                          index > radix_tree_maxindex(root->height)) {
                  error = radix_tree_extend(root, index);
                  if (error)
                          return error;
          }
  
          slot = root->rnode;
          height = root->height;
          shift = (height-1) * RADIX_TREE_MAP_SHIFT;
  
          offset = 0;                     /* uninitialised var warning */
          do {
                  if (slot == NULL) {
                          /* Have to add a child node.  */
                          if (!(slot = radix_tree_node_alloc(root)))
                                  return -ENOMEM;
                          if (node) {
                                  node->slots[offset] = slot;
                                  node->count++;
                          } else
                                  root->rnode = slot;
                  }
  
                  /* Go a level down */
                  offset = (index >> shift) & RADIX_TREE_MAP_MASK;
                  node = slot;
                  slot = node->slots[offset];
                  shift -= RADIX_TREE_MAP_SHIFT;
                  height--;
          } while (height > 0);
  
          if (slot != NULL)
                  return -EEXIST;
  
          BUG_ON(!node);
          node->count++;
          node->slots[offset] = item;
          BUG_ON(tag_get(node, 0, offset));
          BUG_ON(tag_get(node, 1, offset));
  
          return 0;
  }
  ```

  [[CodingStyle\]](http://akaedu.github.io/book/bi01.html#bibli.codingstyle)中特别指出，函数内的注释要尽可能少用。写注释主要是为了说明你的代码“能做什么”（比如函数接口定义），而不是为了说明“怎样做”，只要代码写得足够清晰，“怎样做”是一目了然的，如果你需要用注释才能解释清楚，那就表示你的代码可读性很差，除非是特别需要提醒注意的地方才使用函数内注释。

  5、复杂的结构体定义比函数更需要注释。例如内核源代码目录下的`kernel/sched.c`文件中定义了这样一个结构体：

  ```c
  /*
   * This is the main, per-CPU runqueue data structure.
   *
   * Locking rule: those places that want to lock multiple runqueues
   * (such as the load balancing or the thread migration code), lock
   * acquire operations must be ordered by ascending &runqueue.
   */
  struct runqueue {
          spinlock_t lock;
  
          /*
           * nr_running and cpu_load should be in the same cacheline because
           * remote CPUs use both these fields when doing load calculation.
           */
          unsigned long nr_running;
  #ifdef CONFIG_SMP
          unsigned long cpu_load[3];
  #endif
          unsigned long long nr_switches;
  
          /*
           * This is part of a global counter where only the total sum
           * over all CPUs matters. A task can increase this counter on
           * one CPU and if it got migrated afterwards it may decrease
           * it on another CPU. Always updated under the runqueue lock:
           */
          unsigned long nr_uninterruptible;
  
          unsigned long expired_timestamp;
          unsigned long long timestamp_last_tick;
          task_t *curr, *idle;
          struct mm_struct *prev_mm;
          prio_array_t *active, *expired, arrays[2];
          int best_expired_prio;
          atomic_t nr_iowait;
  
  #ifdef CONFIG_SMP
          struct sched_domain *sd;
  
          /* For active balancing */
          int active_balance;
          int push_cpu;
  
          task_t *migration_thread;
          struct list_head migration_queue;
          int cpu;
  #endif
  
  #ifdef CONFIG_SCHEDSTATS
          /* latency stats */
          struct sched_info rq_sched_info;
  
          /* sys_sched_yield() stats */
          unsigned long yld_exp_empty;
          unsigned long yld_act_empty;
          unsigned long yld_both_empty;
          unsigned long yld_cnt;
  
          /* schedule() stats */
          unsigned long sched_switch;
          unsigned long sched_cnt;
          unsigned long sched_goidle;
  
          /* try_to_wake_up() stats */
          unsigned long ttwu_cnt;
          unsigned long ttwu_local;
  #endif
  };
  ```

  6、复杂的宏定义和变量声明也需要注释。例如内核源代码目录下的`include/linux/jiffies.h`文件中的定义：

  ```c
  /* TICK_USEC_TO_NSEC is the time between ticks in nsec assuming real ACTHZ and  */
  /* a value TUSEC for TICK_USEC (can be set bij adjtimex)                */
  #define TICK_USEC_TO_NSEC(TUSEC) (SH_DIV (TUSEC * USER_HZ * 1000, ACTHZ, 8))
  
  /* some arch's have a small-data section that can be accessed register-relative
   * but that can only take up to, say, 4-byte variables. jiffies being part of
   * an 8-byte variable may not be correctly accessed unless we force the issue
   */
  #define __jiffy_data  __attribute__((section(".data")))
  
  /*
   * The 64-bit value is not volatile - you MUST NOT read it
   * without sampling the sequence number in xtime_lock.
   * get_jiffies_64() will do this for you as appropriate.
   */
  extern u64 __jiffy_data jiffies_64;
  extern unsigned long volatile __jiffy_data jiffies;
  ```

##  三十九、标识符命名

* 标识符命名原则：

  1. 标识符命名要清晰明了，可以使用完整的单词和易于理解的缩写。短的单词可以通过去元音形成缩写，较长的单词可以取单词的头几个字母形成缩写。看别人的代码看多了就可以总结出一些缩写惯例，例如`count`写成`cnt`，`block`写成`blk`，`length`写成`len`，`window`写成`win`，`message`写成`msg`，`number`写成`nr`，`temporary`可以写成`temp`，也可以进一步写成`tmp`，最有意思的是`internationalization`写成`i18n`，词根`trans`经常缩写成`x`，例如`transmit`写成`xmt`。我就不多举例了，请读者在看代码时自己注意总结和积累。

  2. 内核编码风格规定变量、函数和类型采用全小写加下划线的方式命名，常量（比如宏定义和枚举常量）采用全大写加下划线的方式命名，比如上一节举例的函数名`radix_tree_insert`、类型名`struct radix_tree_root`、常量名`RADIX_TREE_MAP_SHIFT`等。

     微软发明了一种变量命名法叫匈牙利命名法（Hungarian notation），在变量名中用前缀表示类型，例如`iCnt`（i表示int）、`pMsg`（p表示pointer）、`lpszText`（lpsz表示long pointer to a zero-ended string）等。Linus在[[CodingStyle\]](http://akaedu.github.io/book/bi01.html#bibli.codingstyle)中毫不客气地讽刺了这种写法：“Encoding the type of a function into the name (so-called Hungarian notation) is brain damaged - the compiler knows the types anyway and can check those, and it only confuses the programmer. No wonder MicroSoft makes buggy programs.”代码风格本来就是一个很有争议的问题，如果你接受本章介绍的内核编码风格（也是本书所有范例代码的风格），就不要使用大小写混合的变量命名方式[[19](http://akaedu.github.io/book/ch09s03.html#ftn.id2738703)]，更不要使用匈牙利命名法。

  3. 全局变量和全局函数的命名一定要详细，不惜多用几个单词多写几个下划线，例如函数名`radix_tree_insert`，因为它们在整个项目的许多源文件中都会用到，必须让使用者明确这个变量或函数是干什么用的。局部变量和只在一个源文件中调用的内部函数的命名可以简略一些，但不能太短。尽量不要使用单个字母做变量名，只有一个例外：用`i`、`j`、`k`做循环变量是可以的。

  4. 针对中国程序员的一条特别规定：禁止用汉语拼音做标识符，可读性极差。

  ------

  [[19](http://akaedu.github.io/book/ch09s03.html#id2738703)] 大小写混合的命名方式是Modern C++风格所提倡的，在C++代码中很普遍，称为CamelCase），大概是因为有高有低像驼峰一样。

##  四十、函数

* 函数设计规则：
  * 1、实现一个函数只是为了做好一件事情，不要把函数设计成用途广泛、面面俱到的，这样的函数肯定会超长，而且往往不可重用，维护困难。
  * 2、函数内部的缩进层次不宜过多，一般以少于4层为宜。如果缩进层次太多就说明设计得太复杂了，应考虑分割成更小的函数（Helper Function）来调用。
  * 3、函数不要写得太长，建议在24行的标准终端上不超过两屏，太长会造成阅读困难，如果一个函数超过两屏就应该考虑分割函数了。[[CodingStyle\]](http://akaedu.github.io/book/bi01.html#bibli.codingstyle)中特别说明，如果一个函数在概念上是简单的，只是长度很长，这倒没关系。例如函数由一个大的`switch`组成，其中有非常多的`case`，这是可以的，因为各`case`分支互不影响，整个函数的复杂度只等于其中一个`case`的复杂度，这种情况很常见，例如TCP协议的状态机实现。
  * 4、执行函数就是执行一个动作，函数名通常应包含动词，例如`get_current`、`radix_tree_insert`。
  * 5、比较重要的函数定义上侧必须加注释，说明此函数的功能、参数、返回值、错误码等。
  * 6、另一种度量函数复杂度的办法是看有多少个局部变量，5到10个局部变量已经很多了，再多就很难维护了，应该考虑分割成多个函数。

##  四十一、indent工具

* `indent`工具可以把代码格式化成某种风格，例如把[例 9.1 “缺少缩进和空白的代码”](http://akaedu.github.io/book/ch09s01.html#codingstyle.badcode)格式化成内核编码风格：

  ```c
  $ indent -kr -i8 main.c 
  $ cat main.c
  #include <stdio.h>
  #include <stdlib.h>
  #include <time.h>
  int main(void)
  {
  	char gesture[3][10] = { "scissor", "stone", "cloth" };
  	int man, computer, result, ret;
  	srand(time(NULL));
  	while (1) {
  		computer = rand() % 3;
  		printf
  		    ("\nInput your gesture (0-scissor 1-stone 2-cloth):\n");
  		ret = scanf("%d", &man);
  		if (ret != 1 || man < 0 || man > 2) {
  			printf("Invalid input! Please input 0, 1 or 2.\n");
  			continue;
  		}
  		printf("Your gesture: %s\tComputer's gesture: %s\n",
  		       gesture[man], gesture[computer]);
  		result = (man - computer + 4) % 3 - 1;
  		if (result > 0)
  			printf("You win!\n");
  		else if (result == 0)
  			printf("Draw!\n");
  		else
  			printf("You lose!\n");
  	}
  	return 0;
  }
  ```

  `-kr`选项表示K&R风格，`-i8`表示缩进8个空格的长度。如果没有指定`-nut`选项，则每8个缩进空格会自动用一个Tab代替。注意`indent`命令会直接修改原文件，而不是打印到屏幕上或者输出到另一个文件，这一点和很多UNIX命令不同。可以看出，`-kr -i8`两个选项格式化出来的代码已经很符合本章介绍的代码风格了，添加了必要的缩进和空白，较长的代码行也会自动折行。美中不足的是没有添加适当的空行，因为`indent`工具也不知道哪几行代码在逻辑上是一组的，空行还是要自己动手添，当然原有的空行肯定不会被`indent`删去的。

##  四十二、单步执行和跟踪函数调用

* 
#  Linux C编程一站式学习笔记

##  一、程序基本概念

###  1、程序和编程语言

* 程序有一系列指令组成，通常包括以下几种：

  * 输入
  * 输出
  * 基本运算
  * 测试分支
  * 循环

* **编写程序可以说就是这样一个过程：把复杂的任务分解成子任务，把子任务再分解成更简单的任务，层层分解，直到最后简单得可以用以上指令来完成。**

* 平台的解释：

  * 计算机体系结构
  * 操作系统
  * 开发平台（编译器、链接器等）

* 编译（compile）过程

  ![编译执行的过程](./images_学习笔记\intro.compile.png)

  * 用文本编辑器写一个C程序，然后保存成一个文件，例如`program.c`（通常C程序的文件名后缀是`.c`），这称为源代码（Source Code）或源文件，
  * 运行编译器编译源文件，编译的过程并不执行程序，而是把源代码全部翻译成机器指令，再加上一些描述信息，生成一个新的文件，例如`a.out`，这称为可执行文件
  * 可执行文件可以被操作系统加载运行，计算机执行该文件中由编译器生成的指令

* 解释（Interpret）过程

  ![解释执行的过程](./images_学习笔记\intro.interpret.png)

* 编程语言演化

  * 机器语言称为第一代语言（1GL，1st Generation Programming Language）
  * 汇编语言称为第二代语言（2GL，2nd Generation Programming Language）
  * C、C++、Java、Python等可以称为第三代语言（3GL，3rd Generation Programming Language）
  * 4GL（4th Generation Programming Language），例如SQL语言（SQL，Structured Query Language，结构化查询语言）
    * 4GL以后的编程语言更多是描述要做什么（Declarative）而不描述具体一步一步怎么做（Imperative）
  * 5GL（5th Generation Programming Language）

###  问题

1. 解释执行的语言相比编译执行的语言有什么优缺点?

##  九、表达式

* 定义：由运算符和操作数所组成的算式

  * 操作数：参与运算的常量和变量

* 运算符优先级

  * 优先级高的先运算

  * 同一优先级的运算从左到右进行

  * | 类别       | 运算符                                 | 结合性   |
    | :--------- | :------------------------------------- | :------- |
    | 后缀       | () [] -> . ++ - -                      | 从左到右 |
    | 一元       | + - ! ~ ++ - -[^前缀] (type)* & sizeof | 从右到左 |
    | 乘除       | * / %                                  | 从左到右 |
    | 加减       | + -                                    | 从左到右 |
    | 移位       | << >>                                  | 从左到右 |
    | 关系       | < <= > >=                              | 从左到右 |
    | 相等       | == !=                                  | 从左到右 |
    | 位与 AND   | &                                      | 从左到右 |
    | 位异或 XOR | ^                                      | 从左到右 |
    | 位或 OR    | \|                                     | 从左到右 |
    | 逻辑与 AND | &&                                     | 从左到右 |
    | 逻辑或 OR  | \|\|                                   | 从左到右 |
    | 条件       | ?:                                     | 从右到左 |
    | 赋值       | = += -= *= /= %=>>= <<= &= ^= \|=      | 从右到左 |
    | 逗号       | ,                                      | 从左到右 |

    [^前缀]:此处++和--是前缀运算符，即`++a`、`--b`

  * ```
    括号成员是老大;      // 括号运算符 []() 成员运算符.  ->
    
    全体单目排老二;      // 所有的单目运算符比如++、 --、 +(正)、 -(负) 、指针运算*、&、sizeof
    
    乘除余三,加减四;    // 这个"余"是指取余运算即%
    
    移位五，关系六;     // 移位运算符：<< >> ，关系：> < >= <= 等
    
    等与不等排行七;     // 即 == 和 !=
    
    位与异或和位或;     // 这几个都是位运算: 位与(&)异或(^)位或(|)    
    
    "三分天下"八九十;  
    
    逻辑与，逻辑或;    // 逻辑运算符: || 和 &&
    
    十一十二紧挨着;    // 注意顺序: 优先级(||)  底于 优先级(&&) 
    
    条件只比赋值高,    // 三目运算符优先级排到 13 位只比赋值运算符和 "," 高
    
    逗号运算最低级!    //逗号运算符优先级最低 
    ```

  * **初等运算符>单目运算符>算术运算符>关系运算符>逻辑运算符>条件运算符>赋值运算符**

    

* 我们定义：在任意表达式后面加个;号也是一种语句，称为表达式语句

  ~~~C
  hour * 60 + minute;//仅运算，不保存计算结果
  
  int total_minute;
  total_minute = hour * 60 + minute;//运算且保存结果到total_minute中
  ~~~

* **任何表达式都有值和类型两个基本属性**

* > 如果一个表达式中出现多个等号，不是从左到右计算而是从右到左计算，例如：
  >
  > ```
  > int total_minute, total;
  > total = total_minute = hour * 60 + minute;
  > ```
  >
  > 计算顺序是先算`hour * 60 + minute`得到一个结果，然后算右边的等号，就是把`hour * 60 + minute`的结果赋给变量`total_minute`，这个结果同时也是整个表达式`total_minute = hour * 60 + minute`的值，再算左边的等号，即把这个值再赋给变量`total`。同样优先级的运算符是从左到右计算还是从右到左计算称为运算符的结合性（Associativity）。+ - * /是左结合的，等号是右结合的。

* > ```
  > printf("%d:%d is %d minutes after 00:00\n", hour, minute, hour * 60 + minute);
  > ```
  >
  > 编译器在翻译这条语句时，首先根据上述语法规则把这个语句解析成下图所示的语法树，然后再根据语法树生成相应的指令。语法树的末端的是一个个Token，每一步展开利用一条语法规则。
  >
  > **图 2.2. 语法树**
  >
  > ![语法树](./images_学习笔记\expr.parse.png)

* 左值和右值

  * 左值：表达式所表示的存储位置
  * 右值：表达式的值
  * **有的表达式既可以做左值也可以做右值，而有的表达式只能做右值**

* > 向下取整的运算称为Floor，用数学符号⌊⌋表示；向上取整的运算称为Ceiling，用数学符号⌈⌉表示。例如：
  >
  > ⌊59/60⌋=0
  > ⌈59/60⌉=1
  > ⌊-59/60⌋=-1
  > ⌈-59/60⌉=0
  >
  > **在C语言中整数除法取的既不是Floor也不是Ceiling，无论操作数是正是负总是把小数部分截掉，在数轴上向零的方向取整（Truncate toward Zero），或者说当操作数为正的时候相当于Floor，当操作符为负的时候相当于Ceiling。**



###  语法规则

* 表达式 → 标识符
* 表达式 → 常量
* 表达式 → 字符串字面值
* 表达式 → (表达式)
* 表达式 → 表达式 + 表达式
* 表达式 → 表达式 - 表达式
* 表达式 → 表达式 * 表达式
* 表达式 → 表达式 / 表达式
* 表达式 → 表达式 = 表达式
* 语句 → 表达式;
* 语句 → printf(表达式, 表达式, 表达式, ...);
* 变量声明 → 类型 标识符 = Initializer, 标识符 = Initializer, ...;（= Initializer的部分可以不写）

###  习题

1、假设变量`x`和`n`是两个正整数，我们知道`x/n`这个表达式的结果要取Floor，例如`x`是17，`n`是4，则结果是4。如果希望结果取Ceiling应该怎么写表达式呢？例如`x`是17，`n`是4，则结果是5；`x`是16，`n`是4，则结果是4。

~~~C
int quotient;
int x = 17,n = 4
    
方案一：//未验证，但感觉有点不对劲
quotient = ~(~x/n);

方案二：//未验证
quotient = (x+n-1)/n;

方案三：//未验证
quotient = x%m>0 ? x/n+1:x/n;
~~~



##  十、字符类型与字符编码

* 字符常量或字符型变量也可以当作整数参与运算，例如：

  ```c
  printf("%c\n", 'a'+1);
  ```

  执行结果是`b`。

* 符号在计算机内部也用数字表示，每个字符在计算机内部用一个整数表示，称为字符编码（Character Encoding），目前最常用的是ASCII码（American Standard Code for Information Interchange，美国信息交换标准码）

  * 常用字符

    | 字符 |   进制   |  数值  |
    | :--: | :------: | :----: |
    | 0—9  | 十六进制 | 30—39  |
    | A—Z  |  十进制  | 65—90  |
    | a—z  |  十进制  | 97—122 |

  * 字符也可以用ASCII码转义序列表示，这种转义序列由\加上1—3个八进制数字组成，或者由`\x`或大写`\X`加上1—2个十六进制数字组成，

##  十一、数学函数

* 小知识点
  * `1.0`是参数（Argument）
  * `log`是函数（Function）
  * `log(1.0)`是函数调用（Function Call）
  * 函数调用也是一种表达式，这个表达式由函数调用运算符（()括号）和两个操作数组成，操作数`log`是一个函数名（Function Designator），它的类型是一种函数类型（Function Type），操作数`1.0`是`double`型的。
  * `log(1.0)`这个表达式的值就是对数运算的结果，也是`double`型的，在C语言中函数调用表达式的值称为函数的返回值（Return Value）
* 语法规则：
  * 表达式 → 函数名
  * 表达式 → 表达式(参数列表)
  * 参数列表 → 表达式, 表达式, ...
* **C语言的函数可以有Side Effect，这一点是它和数学函数在概念上的根本区别**
  * 改变计算机存储单元里的数据或者做输入输出操作都算Side Effect
* 程序第一行的#号（Pound Sign，Number Sign或Hash Sign）和`include`表示包含一个头文件（Header File），后面尖括号（Angel Bracket）中就是文件名（这些头文件通常位于`/usr/include`目录下）。头文件中声明了我们程序中使用的库函数。
* 使用`math.h`中声明的库函数还有一点特殊之处，`gcc`命令行必须加`-lm`选项，因为数学函数位于`libm.so`库文件中（这些库文件通常位于`/lib`目录下），`-lm`选项告诉编译器，我们程序中用到的数学函数要到这个库文件里找

>  C标准库和glibc
>
> C标准主要由两部分组成，一部分描述C的语法，另一部分描述C标准库。C标准库定义了一组标准头文件，每个头文件中包含一些相关的函数、变量、类型声明和宏定义。要在一个平台上支持C语言，不仅要实现C编译器，还要实现C标准库，这样的实现才算符合C标准。不符合C标准的实现也是存在的，例如很多单片机的C语言开发工具中只有C编译器而没有完整的C标准库。
>
> 在Linux平台上最广泛使用的C函数库是`glibc`，其中包括C标准库的实现，也包括本书第三部分介绍的所有系统函数。几乎所有C程序都要调用`glibc`的库函数，所以`glibc`是Linux平台C程序运行的基础。`glibc`提供一组头文件和一组库文件，最基本、最常用的C标准库函数和系统函数在`libc.so`库文件中，几乎所有C程序的运行都依赖于`libc.so`，有些做数学计算的C程序依赖于`libm.so`，以后我们还会看到多线程的C程序依赖于`libpthread.so`。以后我说`libc`时专指`libc.so`这个库文件，而说`glibc`时指的是`glibc`提供的所有库文件。
>
> `glibc`并不是Linux平台唯一的基础C函数库，也有人在开发别的C函数库，比如适用于嵌入式系统的`uClibc`。

##  十二、自定义函数

* 语法规则：

  * 函数定义 → 返回值类型 函数名(参数列表) 函数体
  * 函数体 → { 语句列表 }
  * 语句列表 → 语句列表项 语句列表项 ...
  * 语句列表项 → 语句
  * 语句列表项 → 变量声明、类型声明或非定义的函数声明
  * 非定义的函数声明 → 返回值类型 函数名(参数列表);

* 函数调用的规则和优点

  * 同一个函数可以被多次调用。
  * 可以用一个函数调用另一个函数，后者再去调第三个函数。
  * 通过自定义函数可以给一组复杂的操作起一个简单的名字，例如`threeline`。对于`main`函数来说，只需要通过`threeline`这个简单的名字来调用就行了，不必知道打印三个空行具体怎么做，所有的复杂操作都被隐藏在`threeline`这个名字后面。
  * 使用自定义函数可以使代码更简洁

* 函数原型（Prototype）：比如`void threeline(void)`这一行，声明了一个函数的名字、参数类型和个数、返回值类型，这称为函数原型。在代码中可以单独写一个函数原型，后面加`;`号结束，而不写函数体，例如：

  ```c
  void threeline(void);//正真的函数原型
  void threeline();//不是函数原型
  ```

  这种写法只能叫函数声明而不能叫函数定义，只有带函数体的声明才叫定义

* 函数原型的作用：**为编译器提供了有用的信息**，编译器在翻译代码的过程中，只有见到函数原型（不管带不带函数体）之后才知道这个函数的名字、参数类型和返回值，这样碰到函数调用时才知道怎么生成相应的指令

* 函数调用原则：

  * 先声明后使用
  * 方式：
    * 按调用顺序编写函数
    * 通过函数原型进行声明，后续可以任意顺序进行函数编写
    * 如果不通过函数原型进行声明，先调用，后续编写函数，能编译通过，结果也正确，此处编译器认为此处**隐式声明**了`int threeline(void);`，**隐式声明的函数返回值类型都是`int`，由于我们调用这个函数时没有传任何参数，所以编译器认为这个隐式声明的参数类型是`void`**，这样函数的参数和返回值类型都确定下来了，编译器根据这些信息为函数调用生成相应的指令。然后编译器接着往下看，看到`threeline`函数的原型是`void threeline(void)`，和先前的隐式声明的返回值类型不符，所以报警告。好在我们也没用到这个函数的返回值，所以执行结果仍然正确

##  十三、形参和实参


#  Linux C编程一站式学习笔记

##  一、程序基本概念

###  1、程序和编程语言

* 程序有一系列指令组成，通常包括以下几种：

  * 输入
  * 输出
  * 基本运算
  * 测试分支
  * 循环

* **编写程序可以说就是这样一个过程：把复杂的任务分解成子任务，把子任务再分解成更简单的任务，层层分解，直到最后简单得可以用以上指令来完成。**

* 平台的解释：

  * 计算机体系结构
  * 操作系统
  * 开发平台（编译器、链接器等）

* 编译（compile）过程

  ![编译执行的过程](./images_学习笔记\intro.compile.png)

  * 用文本编辑器写一个C程序，然后保存成一个文件，例如`program.c`（通常C程序的文件名后缀是`.c`），这称为源代码（Source Code）或源文件，
  * 运行编译器编译源文件，编译的过程并不执行程序，而是把源代码全部翻译成机器指令，再加上一些描述信息，生成一个新的文件，例如`a.out`，这称为可执行文件
  * 可执行文件可以被操作系统加载运行，计算机执行该文件中由编译器生成的指令

* 解释（Interpret）过程

  ![解释执行的过程](./images_学习笔记\intro.interpret.png)

* 编程语言演化

  * 机器语言称为第一代语言（1GL，1st Generation Programming Language）
  * 汇编语言称为第二代语言（2GL，2nd Generation Programming Language）
  * C、C++、Java、Python等可以称为第三代语言（3GL，3rd Generation Programming Language）
  * 4GL（4th Generation Programming Language），例如SQL语言（SQL，Structured Query Language，结构化查询语言）
    * 4GL以后的编程语言更多是描述要做什么（Declarative）而不描述具体一步一步怎么做（Imperative）
  * 5GL（5th Generation Programming Language）

###  问题

1. 解释执行的语言相比编译执行的语言有什么优缺点?

##  九、表达式

* 定义：由运算符和操作数所组成的算式

  * 操作数：参与运算的常量和变量

* 运算符优先级

  * 优先级高的先运算

  * 同一优先级的运算从左到右进行

  * | 类别       | 运算符                                 | 结合性   |
    | :--------- | :------------------------------------- | :------- |
    | 后缀       | () [] -> . ++ - -                      | 从左到右 |
    | 一元       | + - ! ~ ++ - -[^前缀] (type)* & sizeof | 从右到左 |
    | 乘除       | * / %                                  | 从左到右 |
    | 加减       | + -                                    | 从左到右 |
    | 移位       | << >>                                  | 从左到右 |
    | 关系       | < <= > >=                              | 从左到右 |
    | 相等       | == !=                                  | 从左到右 |
    | 位与 AND   | &                                      | 从左到右 |
    | 位异或 XOR | ^                                      | 从左到右 |
    | 位或 OR    | \|                                     | 从左到右 |
    | 逻辑与 AND | &&                                     | 从左到右 |
    | 逻辑或 OR  | \|\|                                   | 从左到右 |
    | 条件       | ?:                                     | 从右到左 |
    | 赋值       | = += -= *= /= %=>>= <<= &= ^= \|=      | 从右到左 |
    | 逗号       | ,                                      | 从左到右 |

    [^前缀]:此处++和--是前缀运算符，即`++a`、`--b`

  * ```
    括号成员是老大;      // 括号运算符 []() 成员运算符.  ->
    
    全体单目排老二;      // 所有的单目运算符比如++、 --、 +(正)、 -(负) 、指针运算*、&、sizeof
    
    乘除余三,加减四;    // 这个"余"是指取余运算即%
    
    移位五，关系六;     // 移位运算符：<< >> ，关系：> < >= <= 等
    
    等与不等排行七;     // 即 == 和 !=
    
    位与异或和位或;     // 这几个都是位运算: 位与(&)异或(^)位或(|)    
    
    "三分天下"八九十;  
    
    逻辑与，逻辑或;    // 逻辑运算符: || 和 &&
    
    十一十二紧挨着;    // 注意顺序: 优先级(||)  底于 优先级(&&) 
    
    条件只比赋值高,    // 三目运算符优先级排到 13 位只比赋值运算符和 "," 高
    
    逗号运算最低级!    //逗号运算符优先级最低 
    ```

  * **初等运算符>单目运算符>算术运算符>关系运算符>逻辑运算符>条件运算符>赋值运算符**

    

* 我们定义：在任意表达式后面加个;号也是一种语句，称为表达式语句

  ~~~C
  hour * 60 + minute;//仅运算，不保存计算结果
  
  int total_minute;
  total_minute = hour * 60 + minute;//运算且保存结果到total_minute中
  ~~~

* **任何表达式都有值和类型两个基本属性**

* > 如果一个表达式中出现多个等号，不是从左到右计算而是从右到左计算，例如：
  >
  > ```
  > int total_minute, total;
  > total = total_minute = hour * 60 + minute;
  > ```
  >
  > 计算顺序是先算`hour * 60 + minute`得到一个结果，然后算右边的等号，就是把`hour * 60 + minute`的结果赋给变量`total_minute`，这个结果同时也是整个表达式`total_minute = hour * 60 + minute`的值，再算左边的等号，即把这个值再赋给变量`total`。同样优先级的运算符是从左到右计算还是从右到左计算称为运算符的结合性（Associativity）。+ - * /是左结合的，等号是右结合的。

* > ```
  > printf("%d:%d is %d minutes after 00:00\n", hour, minute, hour * 60 + minute);
  > ```
  >
  > 编译器在翻译这条语句时，首先根据上述语法规则把这个语句解析成下图所示的语法树，然后再根据语法树生成相应的指令。语法树的末端的是一个个Token，每一步展开利用一条语法规则。
  >
  > **图 2.2. 语法树**
  >
  > ![语法树](./images_学习笔记\expr.parse.png)

* 左值和右值

  * 左值：表达式所表示的存储位置
  * 右值：表达式的值
  * **有的表达式既可以做左值也可以做右值，而有的表达式只能做右值**

* > 向下取整的运算称为Floor，用数学符号⌊⌋表示；向上取整的运算称为Ceiling，用数学符号⌈⌉表示。例如：
  >
  > ⌊59/60⌋=0
  > ⌈59/60⌉=1
  > ⌊-59/60⌋=-1
  > ⌈-59/60⌉=0
  >
  > **在C语言中整数除法取的既不是Floor也不是Ceiling，无论操作数是正是负总是把小数部分截掉，在数轴上向零的方向取整（Truncate toward Zero），或者说当操作数为正的时候相当于Floor，当操作符为负的时候相当于Ceiling。**



###  语法规则

* 表达式 → 标识符
* 表达式 → 常量
* 表达式 → 字符串字面值
* 表达式 → (表达式)
* 表达式 → 表达式 + 表达式
* 表达式 → 表达式 - 表达式
* 表达式 → 表达式 * 表达式
* 表达式 → 表达式 / 表达式
* 表达式 → 表达式 = 表达式
* 语句 → 表达式;
* 语句 → printf(表达式, 表达式, 表达式, ...);
* 变量声明 → 类型 标识符 = Initializer, 标识符 = Initializer, ...;（= Initializer的部分可以不写）

###  习题

1、假设变量`x`和`n`是两个正整数，我们知道`x/n`这个表达式的结果要取Floor，例如`x`是17，`n`是4，则结果是4。如果希望结果取Ceiling应该怎么写表达式呢？例如`x`是17，`n`是4，则结果是5；`x`是16，`n`是4，则结果是4。

~~~C
int quotient;
int x = 17,n = 4
    
方案一：//未验证，但感觉有点不对劲
quotient = ~(~x/n);

方案二：//未验证
quotient = (x+n-1)/n;

方案三：//未验证
quotient = x%m>0 ? x/n+1:x/n;
~~~



##  十、字符类型与字符编码

* 字符常量或字符型变量也可以当作整数参与运算，例如：

  ```c
  printf("%c\n", 'a'+1);
  ```

  执行结果是`b`。

* 符号在计算机内部也用数字表示，每个字符在计算机内部用一个整数表示，称为字符编码（Character Encoding），目前最常用的是ASCII码（American Standard Code for Information Interchange，美国信息交换标准码）

  * 常用字符

    | 字符 |   进制   |  数值  |
    | :--: | :------: | :----: |
    | 0—9  | 十六进制 | 30—39  |
    | A—Z  |  十进制  | 65—90  |
    | a—z  |  十进制  | 97—122 |

  * 字符也可以用ASCII码转义序列表示，这种转义序列由\加上1—3个八进制数字组成，或者由`\x`或大写`\X`加上1—2个十六进制数字组成，

##  十一、数学函数

* 小知识点
  * `1.0`是参数（Argument）
  * `log`是函数（Function）
  * `log(1.0)`是函数调用（Function Call）
  * 函数调用也是一种表达式，这个表达式由函数调用运算符（()括号）和两个操作数组成，操作数`log`是一个函数名（Function Designator），它的类型是一种函数类型（Function Type），操作数`1.0`是`double`型的。
  * `log(1.0)`这个表达式的值就是对数运算的结果，也是`double`型的，在C语言中函数调用表达式的值称为函数的返回值（Return Value）
* 语法规则：
  * 表达式 → 函数名
  * 表达式 → 表达式(参数列表)
  * 参数列表 → 表达式, 表达式, ...
* **C语言的函数可以有Side Effect，这一点是它和数学函数在概念上的根本区别**
  * 改变计算机存储单元里的数据或者做输入输出操作都算Side Effect
* 程序第一行的#号（Pound Sign，Number Sign或Hash Sign）和`include`表示包含一个头文件（Header File），后面尖括号（Angel Bracket）中就是文件名（这些头文件通常位于`/usr/include`目录下）。头文件中声明了我们程序中使用的库函数。
* 使用`math.h`中声明的库函数还有一点特殊之处，`gcc`命令行必须加`-lm`选项，因为数学函数位于`libm.so`库文件中（这些库文件通常位于`/lib`目录下），`-lm`选项告诉编译器，我们程序中用到的数学函数要到这个库文件里找

>  C标准库和glibc
>
> C标准主要由两部分组成，一部分描述C的语法，另一部分描述C标准库。C标准库定义了一组标准头文件，每个头文件中包含一些相关的函数、变量、类型声明和宏定义。要在一个平台上支持C语言，不仅要实现C编译器，还要实现C标准库，这样的实现才算符合C标准。不符合C标准的实现也是存在的，例如很多单片机的C语言开发工具中只有C编译器而没有完整的C标准库。
>
> 在Linux平台上最广泛使用的C函数库是`glibc`，其中包括C标准库的实现，也包括本书第三部分介绍的所有系统函数。几乎所有C程序都要调用`glibc`的库函数，所以`glibc`是Linux平台C程序运行的基础。`glibc`提供一组头文件和一组库文件，最基本、最常用的C标准库函数和系统函数在`libc.so`库文件中，几乎所有C程序的运行都依赖于`libc.so`，有些做数学计算的C程序依赖于`libm.so`，以后我们还会看到多线程的C程序依赖于`libpthread.so`。以后我说`libc`时专指`libc.so`这个库文件，而说`glibc`时指的是`glibc`提供的所有库文件。
>
> `glibc`并不是Linux平台唯一的基础C函数库，也有人在开发别的C函数库，比如适用于嵌入式系统的`uClibc`。

##  十二、自定义函数

* 语法规则：

  * 函数定义 → 返回值类型 函数名(参数列表) 函数体
  * 函数体 → { 语句列表 }
  * 语句列表 → 语句列表项 语句列表项 ...
  * 语句列表项 → 语句
  * 语句列表项 → 变量声明、类型声明或非定义的函数声明
  * 非定义的函数声明 → 返回值类型 函数名(参数列表);

* 函数调用的规则和优点

  * 同一个函数可以被多次调用。
  * 可以用一个函数调用另一个函数，后者再去调第三个函数。
  * 通过自定义函数可以给一组复杂的操作起一个简单的名字，例如`threeline`。对于`main`函数来说，只需要通过`threeline`这个简单的名字来调用就行了，不必知道打印三个空行具体怎么做，所有的复杂操作都被隐藏在`threeline`这个名字后面。
  * 使用自定义函数可以使代码更简洁

* 函数原型（Prototype）：比如`void threeline(void)`这一行，声明了一个函数的名字、参数类型和个数、返回值类型，这称为函数原型。在代码中可以单独写一个函数原型，后面加`;`号结束，而不写函数体，例如：

  ```c
  void threeline(void);//正真的函数原型
  void threeline();//不是函数原型
  ```

  这种写法只能叫函数声明而不能叫函数定义，只有带函数体的声明才叫定义

* 函数原型的作用：**为编译器提供了有用的信息**，编译器在翻译代码的过程中，只有见到函数原型（不管带不带函数体）之后才知道这个函数的名字、参数类型和返回值，这样碰到函数调用时才知道怎么生成相应的指令

* 函数调用原则：

  * 先声明后使用
  * 方式：
    * 按调用顺序编写函数
    * 通过函数原型进行声明，后续可以任意顺序进行函数编写
    * 如果不通过函数原型进行声明，先调用，后续编写函数，能编译通过，结果也正确，此处编译器认为此处**隐式声明**了`int threeline(void);`，**隐式声明的函数返回值类型都是`int`，由于我们调用这个函数时没有传任何参数，所以编译器认为这个隐式声明的参数类型是`void`**，这样函数的参数和返回值类型都确定下来了，编译器根据这些信息为函数调用生成相应的指令。然后编译器接着往下看，看到`threeline`函数的原型是`void threeline(void)`，和先前的隐式声明的返回值类型不符，所以报警告。好在我们也没用到这个函数的返回值，所以执行结果仍然正确
  
* 函数只能定义在函数外，不能定义在函数内

* 函数不允许重名，C语言中函数没有重载

* 函数只要一经定义，就可以在任意函数中调用

  注意：如果函数定义在它调用之后，那么必须在调用之前，先声明这个函数

* 声明的语法：返回值类型 函数名(参数列表);

  * tips:声明函数其实只要复制函数头，打个分号就可以了
  * 再注意： 1、函数定义的时候函数头是什么样子，那么声明的时候也必须是这个样子的
  * 2、如果有参数的函数，声明的时候可以省略形参名
  * 3、在Mac下，如果返回值类型是int的话，可以直接调用不声明(不推荐)
  * 4、函数的声明位置可以放在函数内，也可以放在函数外，但是一定要在调用函数之前
  * 5、函数的声明可以写N多个

[(3条消息) c语言声明函数格式 - CSDN](https://www.csdn.net/tags/MtjaQg0sOTgwMDgtYmxvZwO0O0OO0O0O.html)

###  问题

*  问：敏锐的读者可能会发现一个矛盾：如果函数`newline`没有返回值，那么表达式`newline()`不就没有值了吗？然而上一章讲过任何表达式都有值和类型两个基本属性

* 答：其实这正是设计`void`这么一个关键字的原因：首先从语法上规定没有返回值的函数调用表达式有一个`void`类型的值，这样任何表达式都有值，不必考虑特殊情况，编译器的语法解析比较容易实现；然后从语义上规定`void`类型的表达式不能参与运算，因此`newline() + 1`这样的表达式不能通过语义检查，从而兼顾了语法上的一致和语义上的不矛盾。

##  十三、形参和实参

* 形参（Parameter）：即形式参数，又称虚拟变量，是在定义函数名和[函数体](https://baike.baidu.com/item/函数体)的时候使用的参数,目的是用来接收调用该函数时传入的参数.

* 实参（Argument）：实际参数，是在调用时传递给函数的参数。实参可以是常量、变量、表达式、函数等，无论实参是何种类型的量，但必须具有确定的值。

* **实参的个数和数据类型必须和形参一一对应**

* **形参相当于函数中定义的变量，调用函数传递参数的过程相当于定义形参变量并且用实参的值来初始化**

* > ### Man Page
  >
  > Man Page是Linux开发最常用的参考手册，由很多页面组成，每个页面描述一个主题，这些页面被组织成若干个Section。FHS（Filesystem Hierarchy Standard）标准规定了Man Page各Section的含义如下：
  >
  > 
  >
  > **表 3.1. Man Page的Section**
  >
  > | Section | 描述                                                         |
  > | ------- | ------------------------------------------------------------ |
  > | 1       | 用户命令，例如`ls(1)`                                        |
  > | 2       | 系统调用，例如`_exit(2)`                                     |
  > | 3       | 库函数，例如`printf(3)`                                      |
  > | 4       | 特殊文件，例如`null(4)`描述了设备文件`/dev/null`、`/dev/zero`的作用 |
  > | 5       | 系统配置文件的格式，例如`passwd(5)`描述了系统配置文件`/etc/passwd`的格式 |
  > | 6       | 游戏                                                         |
  > | 7       | 其它杂项，例如`bash-builtins(7)`描述了`bash`的各种内建命令   |
  > | 8       | 系统管理命令，例如`ifconfig(8)`                              |
  >
  > 
  >
  > 注意区分用户命令和系统管理命令，用户命令通常位于`/bin`和`/usr/bin`目录，系统管理命令通常位于`/sbin`和`/usr/sbin`目录，一般用户可以执行用户命令，而执行系统管理命令经常需要`root`权限。系统调用和库函数的区别将在[第 2 节 “`main`函数和启动例程”](http://akaedu.github.io/book/ch19s02.html#asmc.main)说明。
  >
  > Man Page中有些页面有重名，比如敲`man printf`命令看到的并不是C函数`printf`，而是位于第1个Section的系统命令`printf`，要查看位于第3个Section的`printf`函数应该敲`man 3 printf`，也可以敲`man -k printf`命令搜索哪些页面的主题包含`printf`关键字。本书会经常出现类似`printf(3)`这样的写法，括号中的3表示Man Page的第3个Section，或者表示“我这里想说的是`printf`库函数而不是`printf`命令”。

###  问题

* 问：为什么参数不能和变量一样，相同类型变量一起定义，而是一个一个定义？

  即不遵循最少例外原则（Rule of Least Surprise）

* 答：

* 问：定义一个函数`increment`，它的作用是把传进来的参数加1。例如：

  ```
  void increment(int x)
  {
  	x = x + 1;
  }
  
  int main(void)
  {
  	int i = 1, j = 2;
  	increment(i); /* i now becomes 2 */
  	increment(j); /* j now becomes 3 */
  	return 0;
  }
  ```

  我们在`main`函数中调用`increment`增加变量`i`和`j`的值，这样能奏效吗？为什么？

* 答：

* 问：如果在一个程序中调用了`printf`函数却不包含头文件，例如`int main(void) { printf("\n"); }`，编译时会报警告：`warning: incompatible implicit declaration of built-in function ‘printf’`。请分析错误原因。

* 答：

##  十四、全局变量、局部变量和作用域

* 局部变量（Local Variable）：函数中定义的变量

  * 一个函数中定义的变量不能被另一个函数使用
  * 每次调用函数时局部变量都表示不同的存储空间。局部变量在每次函数调用时分配存储空间，在每次函数返回时释放存储空间。

* 全局变量（Global Variable）：定义在所有的函数体之外的变量

  * 在任何函数中都可以访问（使用）
  * 在程序开始运行时分配存储空间，在程序结束时释放存储空间

* 在程序运行过程中全局变量被读写的顺序从源代码中是看不出来的，源代码的书写顺序并不能反映函数的调用顺序。在某个不起眼的地方**对全局变量的读写顺序不正确一般会形成BUG。全局变量用起来很方便，但一定要慎用，能用函数传参代替的就不要用全局变量**

* 作用域：限定变量名的可用性的代码范围

* 局部变量和全局变量重名——根据作用域的范围判断，局部变量的作用域会覆盖全局变量的作用域

* **局部变量可以用类型相符的任意表达式来初始化，而全局变量只能用常量表达式（Constant Expression）初始化**

  ~~~C
  double pi = 3.14 + 0.0016;//合法
  double pi = acos(-1.0);//不合法
  int minute = 360;//合法
  int hour = minute / 60;//不合法
  ~~~

  

* 如果全局变量在定义时不初始化则初始值是0，如果局部变量在定义时不初始化则初始值是不确定的。所以，**局部变量在使用之前一定要先赋值**

* 非定义的函数声明也可以写在局部作用域中

###  问题

~~~C
#include <stdio.h>

void foo(void)
{
	int i;
	printf("%d\n", i);
	i = 777;
}

int main(void)
{
	foo();
	foo();
	return 0;
}
~~~

结果：

~~~C
134518128
777
~~~

~~~C
int main(void)
{
	foo();
	printf("hello\n");
	foo();
	return 0;
}
~~~

结果是

~~~C
134518200
hello
0
~~~



* 问：每次调用函数时局部变量都表示不同的存储空间，且局部变量不初始化则初值不确定，即每次调用这个函数时局部变量的初值可能不一样，运行环境不同，函数的调用次序不同，都会影响到局部变量的初值。问为什么这个不确定的值刚好是777，或者刚好是0？是恰好随机为777或0还是其他原因？
* 答：



##  十五、if语句

* 控制表达式：`x != 0`表示“x不等于0”的条件

* 分支（Branch）：`if`和控制表达式改变了程序的控制流程（Control Flow），不再是从前到后顺序执行，而是根据不同的条件执行不同的语句，这种控制流程称为分支

* 小知识点

  * ==表示数学中的相等关系，相当于数学中的=号，在C语言中=号是赋值运算符
  * 如果表达式所表示的比较关系成立则值为真（True），否则为假（False），在C语言中分别用`int`型的1和0表示
  * `==`，`！=`，`>`，`<`，`>=`，`<=`运算符的两个操作数应该是相同类型的，两边都是整型或者都是浮点型可以做比较，但两个字符串不能做比较
  * ==和!=称为相等性运算符（Equality Operator），其余四个称为关系运算符（Relational Operator），相等性运算符的优先级低于关系运算符

* 和`if`语句相关的语法规则如下：

  语句 → if (控制表达式) 语句
  语句 → { 语句列表 }
  语句 → ;

* 在C语言中，任何允许出现语句的地方既可以是由;号结尾的一条语句，也可以是由{}括起来的若干条语句或声明组成的语句块（Statement Block），语句块和上一章介绍的函数体的语法相同

* 在C语言中一个单独的;号表示一条空语句（Null Statement）。

* **语句块中也可以定义局部变量**

  ```c
  void foo(void)
  {
  	int i = 0;
  	{
  		int i = 1;
  		int j = 2;
  		printf("i=%d, j=%d\n", i, j);
  	}
  	printf("i=%d\n", i); /* cannot access j here */
  }
  ```
  
  * 语句块中的变量`i`和函数的局部变量`i`是两个不同的变量，因此两次打印的`i`值是不同的
  * 语句块中的变量`j`在退出语句块之后就没有了，因此最后一行的`printf`不能打印变量`j`
  * 语句块可以用在任何允许出现语句的地方，不一定非得用在`if`语句中，单独使用语句块通常是为了定义一些比函数的局部变量更“局部”的变量

###  习题

* 问：在数学中`a<b<c`表示`b`既大于`a`又小于`c`，但作为C语言表达式却不是这样。以上几种运算符都是左结合的，问这个表达式应如何求值、

* 答：

* 问：以下程序段编译能通过，执行也不出错，但是执行结果不正确（根据[第 3 节 “程序的调试”](http://akaedu.github.io/book/ch01s03.html#intro.debug)的定义，这是一个语义错误），请分析一下哪里错了。还有，既然错了为什么编译能通过呢？

  ```c
  int x = -1;
  if (x > 0);
  	printf("x is positive.\n");
  ```

* 答：

##  十六、if/else语句